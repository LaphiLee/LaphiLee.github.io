<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JVM系列（二）垃圾回收]]></title>
    <url>%2Fposts%2F11644.html</url>
    <content type="text"><![CDATA[JVM系列（二）垃圾回收 Hotspot垃圾收集器 JDK7/8之后，Hotpost虚拟机内所有的垃圾收集器及其组合(连线)，下图： img 他们所处区域，表明其所属新生代收集器还是老年代收集器： 新生代垃圾收集器：Serial、ParNew、Parallel Scavenge 老年代垃圾收集器：Serial Old、Parallel Old、CMS 整堆收集器：G1 两个收集器之间有连线，表明他们可以搭配使用： Serial/Serial Old、Serial/CMS、ParNew/Serial Old、ParNew/CMS、Parallel Scavenge/Serial Old、Parallel Scavenge/Parallel Old、G1 并发垃圾收集器和并行垃圾收集器的区别 并行与并发 并行(Parallel) 指多条垃圾收集线程并行工作，但此时用户线程处于等待状态。 如ParNew、Pallel Scavenge、Parallel Old 并发(Concurrent) 指用户线程与垃圾收集线程同时执行(不一定是并行的，可能会是交替执行)； 用户程序线程继续运行，而垃圾收集线程运行于另一个CPU上。如CMS Minor GC 和 Full GC的区别 1. Minor GC(新生代GC) 又称新生代GC，指发生在新生代区域的垃圾收集动作； 因为Java对象大多是朝生夕灭的，所以Minor GC非常频繁，一般回收速度也比较快。 2. Major GC 、Full GC(年老代GC) 又称老年代GC ,指发生在老年代区域的垃圾收集动作； 出现Full GC(年老代GC)经常会伴随至少一次的Minor GC(不是绝对的，Parallel Sacvenge收集器可以设置策略) Full GC 比 Minor GC 要慢10倍以上。 垃圾收集器介绍 Serial收集器 serial收集器是最基本、历史最悠久的收集器。它是一个单线程的收集器。 它“单线程”的意义并不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它进行垃圾收集时，必须暂停其他所有的工作线程，直到它收集结束。 “Stop the World”这项工作实际上是由虚拟机在后台自动发起和自动完成的，在用户不可见的情况下把用户正常工作的线程全部停掉，用户体验非常差。 我们看下Serial收集器的运行示意图：(书中原图) img 到目前为止，Serial收集器依然是虚拟机运行在Client模式下的默认新生代收集器。 Serial收集器的优点：简单高效 -———————————————————————————————————————– Serial收集器在JDK1.3之前是Hotspot新生代收集的唯一选择 特点 针对新生代； 采用复制算法； 单线程收集； 它进行垃圾收集时，必须暂停所有工作线程，直到收集完成，即“Stop the World” 应用场景 是Hotspot虚拟机在Client模式下 新生代收集器； 对于限定单个CPU的环境来说，Serial收集器没有线程交互(切换)开销，可以获得最高的单线程收集效率； 设置参数 “-XX:+UseSerialGC” ： 该参数用来显示的添加串行垃圾收集器。 运行示意图： img Stop the World 说明 JVM在后台自动发起和自动完成的，在用户不可见的情况下，把用户正常的工作线程全部停掉，即GC停顿； GC停顿带来的用户体验非常差； 从Serial收集器–&gt;Parallel收集器–&gt;CMS–&gt;G1收集器，用户线程停顿的时间在不断缩短，但仍然没法完全消除。 ParNew收集器 ParNew收集器其实就是Serial收集器的多线程版本，除了使用多线程进行垃圾收集之外，其余行为都与Serial收集器一样。 我们看下ParNew收集器工作过程示意图： img ParNew收集器除了多线程收集之外，其他与Serial收集器相比之下，并没有太多创新之处。不过在Server模式下，它是虚拟机首选的新生代收集器，因为它可以与CMS收集器配合使用。 ParNew收集器在单CPU的环境中绝对不会有比Serial收集器更好的效果，甚至由于线程交互的开销，不能百分百保证可以超过Serial收集器。当然随着可以使用的CPU的数量增加，它对于GC时系统资源的有效利用还是很有好处的。它默认开启的收集线程数量与CPU的数量相同。 在CPU非常多的环境下，可以使用“-XX:ParallelGCThreads”参数来限制垃圾收集的线程数量。 -———————————————————————————————————————– ParNew垃圾收集器是Serial收集器的多线程版本。 特点 除了多线程之外，其余的行为、特点与Serial收集器一样。 工作过程示意图： img 应用场景 在Server模式下，ParNew收集器是一个非常重要的收集器，因为除Serial外，目前只有它能与CMS收集器配合工作。在单CPU环境中，不会比Serial收集器有更好的效果，因为存在线程交互开销。 参数设置 -XX:+UseConcMarkSweepGC：指定使用CMS后，会默认使用ParNew作为新生代收集器。 -XX:+UseParNewGC：强制指定使用ParNew收集器 -XX:ParallelGCThreads：指定垃圾收集的线程数量，ParNew默认开启的收集线程与CPU的数量相同。 Parallel Scavenge收集器 Parallel Scavenge收集器是一个新生代收集器，它也是使用复制算法的收集器，又是并行的多线程收集器。 Parallel Scavenge收集器和ParNew的关注点不太一样，其他的收集器关注的都是尽可能的缩短垃圾收集时用户线程停顿的时间。 而Parallel Scavenge收集器的目标则是达到一个可控制的吞吐量。 所谓吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值： 吞吐量 = 运行用户代码时间 / (运行用户代码时间+垃圾收集时间) 虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。 停顿时间越短就越适合于用户交互的程序，良好的响应速度能提升用户体验； 而高吞吐量则可以高效率的利用CPU时间，尽快完成程序的运算任务，适合在后台运算而不需要太多交互的任务。 -XX:MaxGCPauseMillis： 控制最大垃圾收集停顿时间； 参数是大于0的毫秒数，收集器将尽可能保证内存回收不超过设定的值。 GC停顿时间缩短是以牺牲吞吐量量和新生代空间来换取的。 以前10秒收集一次，每次停顿100毫秒，现在变成5秒收集一次，每次停顿70毫秒；停顿时间的确在下降，但吞吐量也下降了。 -XX:GCTimeRatio： 直接设置吞吐量大小； 参数的值应当是一个大于0且小于100的整数，也就是垃圾收集时间占总时间的比率，相当于是吞吐量的倒数。 如果把此参数设置为19，那允许的最大GC时间就占总时间的5%（即 1/(1+19)），默认值是99，就是允许最大1%（即 1/(1+99)）的垃圾收集时间 由于与吞吐量关系密切，Parallel Scavenge收集器也被称为“吞吐量优先”收集器。 -XX:+UseAdaptiveSizePolicy：这是一个参数开关，当这个参数打开之后，就不需要手工指定新生代大小等细节参数了，虚拟机会根据当前系统运行状态收集性能监控信息。 动态调整这些参数，这种调节方式被称为“GC自适应的调节策略”。自适应策略也是Parallel Scavenge收集器与ParNew收集器一个重要区别。 -———————————————————————————————————————– Parallel Scavenge垃圾收集器因为与吞吐量关系密切，也称为吞吐量收集器 特点 新生代收集器、采用复制算法、多线程收集 —- 与ParNew收集器相同 主要特点： 它关注吞吐量，目标是达到一个可控制的吞吐量 应用场景 高吞吐量为目标，即减少垃圾收集时间，让用户代码获得更长的运行时间。 当应用程序运行在多个CPU上，对暂停时间没有特别高的要求时，即程序主要在后台运行计算，而不需要与用户进行太多的交互 设置参数 -XX:MaxGCPauseMillis ​ 控制最大垃圾收集时间，大于0的毫秒数。 ​ MaxGCPauseMillis设置的稍小，停顿时间可能会缩短，但也可能会使得吞吐量下降，因为可能导致垃圾收集发生的更频繁。 -XX:GCTimeRatio 设置垃圾收集时间占总时间的比率，0 &lt; n &lt; 100的整数。 GCTimeRatio相当于设置吞吐量大小。 垃圾收集执行时间占应用程序执行时间的比例计算方法：1 / (1+n) 例如，选项-XX:GCTimeRatio=19，设置了垃圾收集时间占总时间的5%，1 / (1+19) 它的默认值为1%，1 / (1+99)，即n = 99； 垃圾收集所花费的时间是年轻代和年老代收集的总时间； -XX:+UseAdaptiveSizePolicy 开启这个参数之后，就不用手工指定一些细节参数，JVM会动态调整，GC自适应的调节策略。 吞吐量与收集器关注点说明 吞吐量 CPU用于运行用户代码的时间 与 CPU总消耗时间的比值，即： ​ 吞吐量 = 运行用户代码时间 / (运行用户代码时间 + 垃圾收集时间) ​ 高吞吐量即减少垃圾收集时间，让用户代码获得更长时间的运行时间。 垃圾收集器期望的目标 停顿时间 停顿时间越短就越适合于用户交互的程序，良好的响应速度能提升用户体验。 吞吐量 高吞吐量则可以高效率利用CPU时间，尽快完成运算任务。适合在后台计算而不需要太多交互的任务。 覆盖区 在达到前面两点的情况下，尽量减少堆的内存空间，可以获得更好的空间局部性。 Serial Old收集器 Serial Old是Serial收集器的年老代版本，同样是一个单线程收集器，使用“标记-整理”算法。 这个收集器的主要意义也是在于给Client模式下的虚拟机使用的。 在Server模式下，它还有两大用途： 在JDK1.5之前的版本与Parallel Scavenge收集器搭配使用。 作为CMS收集器的后备方案。(后面再说) 执行过程如下图：(书中原图) img -———————————————————————————————————————– img Parallel Old收集器 Parallel Old收集器是Parallel Scavenge收集器的老年代版本； 特点 针对年老代； 采用“标记-整理”算法； 多线程收集； 应用场景 JDK1.6之后才出现，用来代替年老代的Serial Old收集器。 在Server模式、多CPU、这种注重吞吐量以及CPU资源敏感的场景，就有了Parallel Scavenge + Parallel Old收集器这样给力的组合。 设置参数 -XX:+UseParallelOldGC：指定使用Parallel Old收集器。 运行过程如下图： img CMS收集器 CMS并发标记清理收集器也被称为并发低停顿收集器或低延迟垃圾收集器。 CMS收集器是一种以获取最短回收停顿时间为目标的收集器。 特点 针对年老代； 基于“标记-清除”算法； 以获取最短回收停顿时间为目标； 并发收集、低停顿； 需要更多的内存； JDK1.5之后推出的第一款真正意义上的并发收集器； 第一次实现了让垃圾收集器与用户线程同时工作； 应用场景 与用户交互较多的场景； 希望系统停顿时间最短，注重服务的相应速度；提高用户体验。(常见web、b/s系统的服务上的应用) 设置参数 -XX:+UseConcMarkSweepGC： 指定使用CMS收集器 CMS收集器运作过程 CMS收集器的运行过程比较复杂，分文以下四步： 初始标记 仅标记一下GC Roots能直接关联到的对象； 速度很快，但需要“Stop the World” 并发标记 进行GC Roots Tracing的过程； ​ 应用程序也在运行； ​ 并不能保证可以标记出所有的存活对象； 重新标记 为了修正并发标记期间因用户程序继续运行而导致标记变动的那一部分对象的标记记录。 ​ 需要“Stop the World”，且停顿时间比初始标记稍长，但远比并发标记短。 ​ 采用多线程并行执行来提升效率。 并发清除 回收所有的垃圾对象。 ​ 整个过程中耗时最长的并发标记和并发清除都可以与用户线程一起工作； ​ 所以总体上说，CMS收集器的内存回收过程与用户线程一起并发执行； CMS收集器运行过程示意图 img CMS收集器3个明显的缺点 对CPU资源非常敏感 并发收集虽然不会暂停用户线程，但因为占用一部分CPU资源，还是会导致应用程序变慢，总吞吐量降低。 ​ CMS默认的收集线程数量是 = (CPU数量 + 3)/4; ​ 当CPU数量多于4个，收集线程占用的CPU资源多于25%，对用户程序影响可能较大；不足4个时，影响更大，可能无法接受。 ​ 注：针对这种情况，曾出现了“增量式并发收集器”。类似使用抢占式来模拟多任务机制的思想，让收集线程和用户线程交替运行，减少收集线程运行时间。不过效果不理想，JDK1.6之后不提倡使用。 无法处理浮动垃圾，可能出现“Concurrent Mode Failure”失败 浮动垃圾 在并发清除时，用户线程新产生的垃圾，称为浮动垃圾； 这使得并发清除时需要预留一定的内存空间，不能像其他收集器一样，在年老代几乎填满再进行收集。 也可以认为CMS收集器所需要的空间比其他垃圾收集器大。 `-XX:CMSInitiatingOccupancyFraction`：设置CMS预留内存空间； JDK1.5默认设置下，CMS收集器当年老带使用了68%的空间之后就会被激活。 JDK1.6大约 年老代使用了92%的空间之后，CMS收集器就会被激活。 “Concurrent Mode Failure”失败 如果CMS预留内存空间无法满足程序需要，就会出现一次“Concurrent Mode Failure”失败。这时JVM启动后备预案：临时启动Serial Old收集器，而导致另一次Full GC的产生。这样做的代价是很大的，所以CMSInitiatingOccupancyFraction不能设置的太大。 产生大量内存碎片 由于CMS收集器基于“标记-清除”算法，清除后不能进行压缩操作。 ​ 之前在讲“标记-清除”算法的时候，曾介绍过：产生大量不连续的内存碎片会导致分配大内存对象时，无法找到足够的连续内存，从而需要提前触发另一次Full GC动作。 解决方法 -XX:+UseCMSCompactAtFullCollection 使得CMS出现上面这种情况时，不进行Full GC，而是开启内存碎片的合并并整理。但是合并整理过程无法并发，停顿时间会变长。默认开启(但不会进行，结合下面的CMSFullGCBeforeCompaction) -XX:+CMSFullGCBeforeCompaction 设置执行多少次不压缩的Full GC之后，来一次压缩整理。为了减少合并整理过程的停顿时间。默认为0，也就是说每次执行Full GC，不会进行压缩整理。由于空间不在连续，CMS需要使用可用“空闲列表”内存分配方式，这比简单实用的“碰撞指针”分配内存消耗大。 总的来看，与Parallel Old垃圾收集器相比，CMS减少了执行年老代垃圾收集时应用暂停的时间，但却增加了新生代垃圾收集时应用暂停的时间、降低了吞吐量，而且需要占用更大的堆空间。 G1收集器 G1是一款面向服务端应用的垃圾收集器。 特点 并行与并发 能充分利用多CPU、多核环境下的硬件优势； 可以并行来缩短“Stop the World”停顿时间； 也可以并发让垃圾收集与用户程序同时进行； 分代收集，收集范围包括新生代和年老代 能独立管理整个GC堆(新生代、年老代)，而不需要与其他收集器搭配。 能够采用不同方式处理不同时期的对象。 虽然保留分代概念，但Java堆的内存布局有很大差别。 将整个堆划分为多个大小相等的独立区域(Region)； 新生代和年老代不再是物理隔离，它们都是一部分Region(不需要连续)的集合。 以下是书中原文，关于Region的解释： 在G1之前的其他收集器进行收集的范围都是整个新生代或者年老代，而G1不再是这样。使用G1收集器时，Java堆的内存布局就与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域(Region)，虽然还保留有新生代和年老代的概念，但新生代和年老代不再是物理隔离得到了，它们都是一部分Region(不需要连续)的集合。 结合多种垃圾收集算法、空间整合，不产生碎片 从整体来看，是基于标记-整理算法； 从局部(两个Region)来看，是基于复制算法； 两种算法都不会产生内存碎片，收集后能提供规整的可用内存，有利于长时间运行。 可预测的停顿：低停顿的同时实现高吞吐量 G1除了追求低停顿外，还能建立可预测的停顿时间模型； 可以明确指定M毫秒时间片内，垃圾收集消耗的时间不超过N毫秒。 应用场景 面向服务端应用，针对具有大内存、多处理器的机器 最主要是为 需要 低GC延迟，并具有大堆的应用程序提供解决方案； 如：在堆大小约6GB或更大时，可预测的暂停时间可以低于0.5秒。 用来替换掉JDK1.5中的CMS收集器。 在下面的情况中，使用G1可能比CMS好： 超过50%的Java堆被活动数据占用 对象分配频率或年老代提升频率变化很大 GC停顿时间过长(长于0.5 至 1秒) 那么是否应要采用G1呢？也不一定：如果现在采用的收集器没有出现问题，不用着急去选择G1，如果应用程序追求低停顿，可以尝试选择G1; 是否代替CMS需要实际场景测试才知道 设置参数 -XX:UseG1GC：指定使用G1收集器。 -XX:InitiatingHeapOccupancyPercent：当整个Java堆的占用率达到参数值时，开始并发标记阶段，默认为45。 -XX:MaxGCPauseMillis：为G1收集器设置暂停时间目标，默认值为200毫秒 -XX:G1HeapRegionSize：设置每个Region大小，范围1MB到32MB；在最小Java堆时可以拥有大约2048个Region 为什么G1垃圾收集器可以实现“可预测”的停顿 G1垃圾收集器可以建立可预测得到停顿时间模式，是因为： 可以有计划的避免 在Java堆进行全区域的垃圾收集。 G1跟踪各个Region获得其收集价值大小，在后台维护一个优先列表。 每次根据允许的收集时间，优先回收价值最大的Region。 这样子，就保证了在有限的时间内可以获取尽可能高的收集效率。 G1收集器运作过程 G1垃圾收集器的运作过程与CMS比较相似。 初始标记 ​ 仅标记一下GC Roots能直接关联到的对象。 ​ 且修改TAMS(Next Top at Mark Sart)，让下一阶段并发运行时，用户程序能在正确可用的Region中创建新对象。 ​ 需要“Stop The World”，但速度很快。 并发标记 ​ 进行GC Roots Tracing的过程。 ​ 刚才产生的集合中标记出存活对象。 ​ 耗时较长，但应用程序也在运行。 ​ 并不能保证可以标记出所有的存活对象。 最终标记 为了修正并发标记期间，因用户程序继续运作，而导致标记变动的那一部分对象的标记记录。需要“Stop The World”，且停顿时间比初始标记稍长，但远比并发标记短。 ​ 采用多线程并行执行来提高效率。 筛选回收 首先排序各个Region的回收价值和成本； 然后根据用户期望的GC停顿时间来制定回收计划； 按计划回收一些价值高的Region中的垃圾对象； 回收时采用“复制”算法，从一个或多个Region复制存活对象到堆上的另一个空的Region，并且在此过程中压缩和释放内存； 可以并发运行，降低停顿时间，并增加吞吐量。 G1收集器运行过程如下图： img 参考资料 http://blog.csdn.net/Simba_cheng/article/details/78218541?locationNum=5&amp;fps=1 http://www.jianshu.com/p/c9ac99b87d56]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jvm</tag>
        <tag>java虚拟机</tag>
        <tag>gc</tag>
        <tag>垃圾回收</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM系列（一）Java虚拟机体系结构]]></title>
    <url>%2Fposts%2F64150.html</url>
    <content type="text"><![CDATA[概述 众所周知，Java支持平台无关性、安全性和网络移动性。而Java平台由Java虚拟机和Java核心类所构成，它为纯Java程序提供了统一的编程接口，而不管下层操作系统是什么。正是得益于Java虚拟机，它号称的“一次编译，到处运行”才能有所保障。 Java程序执行流程 Java程序的执行依赖于编译环境和运行环境。源码代码转变成可执行的机器代码，由下面的流程完成： img Java技术的核心就是Java虚拟机，因为所有的Java程序都在虚拟机上运行。Java程序的运行需要Java虚拟机、Java API和Java Class文件的配合。Java虚拟机实例负责运行一个Java程序。当启动一个Java程序时，一个虚拟机实例就诞生了。当程序结束，这个虚拟机实例也就消亡。 img Java的跨平台特性，因为它有针对不同平台的虚拟机。 Java虚拟机 Java虚拟机的主要任务是装载class文件并且执行其中的字节码。由下图可以看出，Java虚拟机包含一个类装载器（class loader），它可以从程序和API中装载class文件，Java API中只有程序执行时需要的类才会被装载，字节码由执行引擎来执行。 img 当Java虚拟机由主机操作系统上的软件实现时，Java程序通过调用本地方法和主机进行交互。Java方法由Java语言编写，编译成字节码，存储在class文件中。本地方法由C/C++/汇编语言编写，编译成和处理器相关的机器代码，存储在动态链接库中，格式是各个平台专有。所以本地方法是联系Java程序和底层主机操作系统的连接方式。 由于Java虚拟机并不知道某个class文件是如何被创建的，是否被篡改一无所知，所以它实现了一个class文件检测器，确保class文件中定义的类型可以安全地使用。class文件检验器通过四趟独立的扫描来保证程序的健壮性： class文件的结构检查 类型数据的语义检查 字节码验证 符号引用验证 Java虚拟机在执行字节码时还进行其它的一些内置的安全机制的操作，他们作为Java编程语言保证Java程序健壮性的特性，同时也是Java虚拟机的特性： 类型安全的引用转换 结构化的内存访问 自动垃圾收集 数组边界检查 空引用检查 Java虚拟机数据类型 Java虚拟机通过某些数据类型来执行计算。数据类型可以分为两种：基本类型和引用类型，如下图： img 但boolean有点特别，当编译器把Java源码编译为字节码时，它会用int或byte表示boolean。在Java虚拟机中，false是由0表示，而true则由所有非零整数表示。和Java语言一样，Java虚拟机的基本类型的值域在任何地方都是一致的，不管主机平台是什么，一个long在任何虚拟机中总是一个64位二进制补码的有符号整数。 对于returnAddress，这个基本类型被用来实现Java程序中的finally子句，Java程序员不能使用这个类型，它的值指向一条虚拟机指令的操作码。 体系结构 在 Java虚拟机规范中，一个虚拟机实例的行为是分别按照子系统、内存区、数据类型和指令来描述的，这些组成部分一起展示了抽象的虚拟机的内部体系结构。 img class文件 Java class文件包含了关于类或接口的所有信息。class文件的“基本类型”如下： u1 1个字节，无符号类型 u2 2个字节，无符号类型 u4 4个字节，无符号类型 u8 8个字节，无符号类型 如果想了解更多，Oracle的JVM SE7给出了官方规范：The Java® Virtual Machine Specification class文件包含的内容： 1234567891011121314151617181920ClassFile &#123; u4 magic; //魔数：0xCAFEBABE，用来判断是否是Java class文件 u2 minor_version; //次版本号 u2 major_version; //主版本号 u2 constant_pool_count; //常量池大小 cp_info constant_pool[constant_pool_count-1]; //常量池 u2 access_flags; //类和接口层次的访问标志（通过|运算得到） u2 this_class; //类索引（指向常量池中的类常量） u2 super_class; //父类索引（指向常量池中的类常量） u2 interfaces_count; //接口索引计数器 u2 interfaces[interfaces_count]; //接口索引集合 u2 fields_count; //字段数量计数器 field_info fields[fields_count]; //字段表集合 u2 methods_count; //方法数量计数器 method_info methods[methods_count]; //方法表集合 u2 attributes_count; //属性个数 attribute_info attributes[attributes_count]; //属性表&#125; 类装载器子系统 类装载器子系统负责查找并装载类型信息。其实Java虚拟机有两种类装载器：系统装载器和用户自定义装载器。前者是Java虚拟机实现的一部分，后者则是Java程序的一部分。 img 启动类装载器（bootstrap class loader）：它用来加载 Java 的核心库，是用原生代码来实现的，并不继承自java.lang.ClassLoader。 扩展类装载器（extensions class loader）：它用来加载 Java 的扩展库。Java 虚拟机的实现会提供一个扩展库目录。该类加载器在此目录里面查找并加载 Java 类。 应用程序类装载器（application class loader）：它根据 Java 应用的类路径（CLASSPATH）来加载 Java 类。一般来说，Java 应用的类都是由它来完成加载的。可以通过 ClassLoader.getSystemClassLoader()来获取它。 除了系统提供的类装载器以外，开发人员可以通过继承 java.lang.ClassLoader类的方式实现自己的类装载器，以满足一些特殊的需求。 类装载器子系统涉及Java虚拟机的其它几个组成部分以及来自java.lang库的类。ClassLoader定义的方法为程序提供了访问类装载器机制的接口。此外，对于每一个被装载的类型，Java虚拟机都会为它创建一个java.lang.Class类的实例来代表该类型。和其它对象一样，用户自定义的类装载器以及Class类的实例放在内存中的堆区，而装载的类型信息则位于方法区。 类装载器子系统除了要定位和导入二进制class文件外，还必须负责验证被导入类的正确性，为类变量分配并初始化内存，以及解析符号引用。这些动作还需要按照以下顺序进行： 装载（查找并装载类型的二进制数据） 连接（执行验证：确保被导入类型的正确性；准备：为类变量分配内存，并将其初始化为默认值；解析：把类型中的符号引用转换为直接引用） 初始化（类变量初始化为正确初始值） 方法区 在Java虚拟机中，关于被装载的类型信息存储在一个方法区的内存中。当虚拟机装载某个类型时，它使用类装载器定位相应的class文件，然后读入这个class文件并将它传输到虚拟机中，接着虚拟机提取其中的类型信息，并将这些信息存储到方法区。方法区也可以被垃圾回收器收集，因为虚拟机允许通过用户定义的类装载器来动态扩展Java程序。 方法区中存放了以下信息： 这个类型的全限定名（如全限定名java.lang.Object） 这个类型的直接超类的全限定名 这个类型是类类型还是接口类型 这个类型的访问修饰符（public, abstract, final的某个子集） 任何直接超接口的全限定名的有序列表 该类型的常量池（一个有序集合，包括直接常量[string, integer和floating point常量]和对其它类型、字段和方法的符号引用） 字段信息（字段名、类型、修饰符） 方法信息（方法名、返回类型、参数数量和类型、修饰符） 除了常量以外的所有类（静态）变量 指向ClassLoader类的引用（每个类型被装载时，虚拟机必须跟踪它是由启动类装载器还是由用户自定义类装载器装载的） 指向Class类的引用（对于每一个被装载的类型，虚拟机相应地为它创建一个java.lang.Class类的实例。比如你有一个到java.lang.Integer类的对象的引用，那么只需要调用Integer对象引用的getClass()方法，就可以得到表示java.lang.Integer类的Class对象） 方法区（Method Area）与Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然Java 虚拟机规范把方法区描述为堆的一个逻辑部分，但是它却有一个别名叫做Non-Heap（非堆），目的应该是与Java 堆区分开来。 对于习惯在HotSpot 虚拟机上开发和部署程序的开发者来说，很多人愿意把方法区称为“永久代”（Permanent Generation），本质上两者并不等价，仅仅是因为HotSpot 虚拟机的设计团队选择把GC 分代收集扩展至方法区，或者说使用永久代来实现方法区而已。对于其他虚拟机（如BEA JRockit、IBM J9 等）来说是不存在永久代的概念的。即使是HotSpot 虚拟机本身，根据官方发布的路线图信息，现在也有放弃永久代并“搬家”至Native Memory 来实现方法区的规划了。 Java 虚拟机规范对这个区域的限制非常宽松，除了和Java 堆一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入了方法区就如永久代的名字一样“永久”存在了。这个区域的内存回收目标主要是针对常量池的回收和对类型的卸载，一般来说这个区域的回收“成绩”比较难以令人满意，尤其是类型的卸载，条件相当苛刻，但是这部分区域的回收确实是有必要的。在Sun 公司的BUG 列表中，曾出现过的若干个严重的BUG 就是由于低版本的HotSpot 虚拟机对此区域未完全回收而导致内存泄漏。根据Java 虚拟机规范的规定，当方法区无法满足内存分配需求时，将抛出OutOfMemoryError 异常。 运行时常量池（Runtime Constant Pool）是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述等信息外，还有一项信息是常量池（Constant PoolTable），用于存放编译期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池中。 Java 虚拟机对Class 文件的每一部分（自然也包括常量池）的格式都有严格的规定，每一个字节用于存储哪种数据都必须符合规范上的要求，这样才会被虚拟机认可、装载和执行。但对于运行时常量池，Java 虚拟机规范没有做任何细节的要求，不同的提供商实现的虚拟机可以按照自己的需要来实现这个内存区域。不过，一般来说，除了保存Class 文件中描述的符号引用外，还会把翻译出来的直接引用也存储在运行时常量池中①。运行时常量池相对于Class 文件常量池的另外一个重要特征是具备动态性，Java 语言并不要求常量一定只能在编译期产生，也就是并非预置入Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可能将新的常量放入池中，这种特性被开发人员利用得比较多的便是String 类的intern() 方法。既然运行时常量池是方法区的一部分，自然会受到方法区内存的限制，当常量池无法再申请到内存时会抛出OutOfMemoryError 异常。 堆 Java程序在运行时创建的所有类实例或数组（数组在Java虚拟机中是一个真正的对象）都放在同一个堆中。由于Java虚拟机实例只有一个堆空间，所以所有线程都将共享这个堆。需要注意的是，Java虚拟机有一条在堆中分配对象的指令，却没有释放内存的指令，因为虚拟机把这个任务交给垃圾收集器处理。Java虚拟机规范并没有强制规定垃圾收集器，它只要求虚拟机实现必须“以某种方式”管理自己的堆空间。比如某个实现可能只有固定大小的堆空间，当空间填满，它就简单抛出OutOfMemory异常，根本不考虑回收垃圾对象的问题，但却是符合规范的。 Java虚拟机规范并没有规定Java对象在堆中如何表示，这给虚拟机的实现者决定怎么设计。一个可能的堆设计如下： img 一个句柄池，一个对象池。一个对象的引用就是一个指向句柄池的本地指针。这种设计的好处有利于堆碎片的整理，当移动对象池中的对象时，句柄部分只需更改一下指针指向对象的新地址即可。缺点是每次访问对象的实例变量都要经过两次指针传递。 对于大多数应用来说，Java 堆（Java Heap）是Java 虚拟机所管理的内存中最大的一块。Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在Java 虚拟机规范中的描述是：所有的对象实例以及数组都要在堆上分配①，但是随着JIT 编译器的发展与逃逸分析技术的逐渐成熟，栈上分配、标量替换②优化技术将会导致一些微妙的变化发生，所有的对象都分配在堆上也渐渐变得不是那么“绝对”了。Java 堆是垃圾收集器管理的主要区域，因此很多时候也被称做“GC 堆”（GarbageCollected Heap，幸好国内没翻译成“垃圾堆”）。如果从内存回收的角度看，由于现在收集器基本都是采用的分代收集算法，所以Java 堆中还可以细分为：新生代和老年代；再细致一点的有Eden 空间、From Survivor 空间、To Survivor 空间等。如果从内存分配的角度看，线程共享的Java 堆中可能划分出多个线程私有的分配缓冲区（Thread LocalAllocation Buffer，TLAB）。不过，无论如何划分，都与存放内容无关，无论哪个区域，存储的都仍然是对象实例，进一步划分的目的是为了更好地回收内存，或者更快地分配内存。根据Java 虚拟机规范的规定，Java 堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。在实现时，既可以实现成固定大小的，也可以是可扩展的，不过当前主流的虚拟机都是按照可扩展来实现的（通过-Xmx和-Xms 控制）。如果在堆中没有内存完成实例分配，并且堆也无法再扩展时，将会抛出OutOfMemoryError 异常。 新生代 ( Young ) 与老年代 ( Old ) 的比例的值为 1:2 ( 该值可以通过参数 –XX:NewRatio 来指定 ) 默认的，Eden : from : to = 8 : 1 : 1 ( 可以通过参数 –XX:SurvivorRatio 来设定 )，即： Eden = 8/10 的新生代空间大小，from = to = 1/10 的新生代空间大小。 堆内存和垃圾收集是密不可分的两个主题，讲垃圾收集的资料很多，但总的来说讲的比较混乱，在这里我试图从一个系统的视角展示垃圾收集。 垃圾收集的意义 垃圾收集的出现解放了C++中手工对内存进行管理的大量繁杂工作，手工malloc,free不仅增加程序复杂度，还增加了bug数量。 分代收集。即在新生代和老生代使用不同的收集方式。在垃圾收集上，目标主要有：加大系统吞吐量（减少总垃圾收集的资源消耗）；减少最大STW（Stop-The-World）时间；减少总STW时间。不同的系统需要不同的达成目标。而分代这一里程碑式的进步首先极大减少了STW，然后可以自由组合来达到预定目标。 可达性检测 引用计数：一种在jdk1.2之前被使用的垃圾收集算法，我们需要了解其思想。其主要思想就是维护一个counter，当counter为0的时候认为对象没有引用，可以被回收。缺点是无法处理循环引用。目前iOS开发中的一个常见技术ARC（Automatic Reference Counting）也是采用类似的思路。在当前的JVM中应该是没有被使用的。 根搜算法：思想是从gc root根据引用关系来遍历整个堆并作标记，称之为mark，等会在具体收集器中介绍并行标记和单线程标记。之后回收掉未被mark的对象，好处是解决了循环依赖这种『孤岛效应』。这里的gc root主要指： 虚拟机栈(栈桢中的本地变量表)中的引用的对象 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中JNI的引用的对象 整理策略 复制：主要用在新生代的回收上，通过from区和to区的来回拷贝。需要特定的结构（也就是Young区现在的结构）来支持，对于新生成的对象来说，频繁的去复制可以最快的找到那些不用的对象并回收掉空间。所以说在JVM里YGC一定承担了最大量的垃圾清除任务。 标记清除/标记整理：主要用在老生代回收上，通过根搜的标记然后清除或者整理掉不需要的对象。 这里清除会产生碎片空间，对内存利用不是很好，但不是说整理优于清除，毕竟整理会更慢。比如CMSGC就是使用清除而不是整理的。 思考一下复制和标记清除/整理的区别，为什么新生代要用复制？因为对新生代来讲，一次垃圾收集要回收掉绝大部分对象，我们通过冗余空间的办法来加速整理过程（不冗余空间的整理操作要做swap，而冗余只需要做move）。同时可以记录下每个对象的『年龄』从而优化『晋升』操作使得中年对象不被错误放到老年代。而反过来老年代偏稳定，我们哪怕是用清除，也不会产生太多的碎片，并且整理的代价也并不会太大。 Java栈 每当启动给一个线程时，Java虚拟机会为它分配一个Java栈。Java栈由许多栈帧组成，一个栈帧包含一个Java方法调用的状态。当线程调用一个Java方法时，虚拟机压入一个新的栈帧到该线程的Java栈中，当该方法返回时，这个栈帧就从Java栈中弹出。Java栈存储线程中Java方法调用的状态–包括局部变量、参数、返回值以及运算的中间结果等。Java虚拟机没有寄存器，其指令集使用Java栈来存储中间数据。这样设计的原因是为了保持Java虚拟机的指令集尽量紧凑，同时也便于Java虚拟机在只有很少通用寄存器的平台上实现。另外，基于栈的体系结构，也有助于运行时某些虚拟机实现的动态编译器和即时编译器的代码优化。 这个栈和数据结构中的stack有相似之处，但并不是用户态的。准确的讲它压入的每个栈帧（Stack Frame）是程序指令以及局部变量表，每个方法调用对应一个栈帧。局部变量表包括各种基本数据类型：boolean、byte、char、short、int、float、long、double以及对象的引用。我们需要注意到每个线程都有独立的栈并且是互相隔离的。 栈的大小可以受到几个因素影响，一个是jvm参数 -XSS，默认值随着虚拟机版本以及操作系统影响，从Oracle官网上我们可以找到： 1In Java SE 6, the default on Sparc is 512k in the 32-bit VM, and 1024k in the 64-bit VM. On x86 Solaris/Linux it is 320k in the 32-bit VM and 1024k in the 64-bit VM. 我们可以认为64位linux默认是1m的样子。 除了JVM设置，我们还可以在创建Thread的时候手工指定大小： public Thread(ThreadGroup group, Runnable target, String name , long stackSize) 栈的大小影响到了线程的最大数量，尤其在大流量的server中，我们很多时候的并发数受到的是线程数的限制，这时候需要了解限制在哪里。 第一个限制在操作系统，以ubuntu为例，/proc/sys/kernel/threads-max 和/proc/sys/vm/max_map_count 定义了总的最大线程数（根据资料windows总的来说线程数会更少）和mmap这个system_call的最大数量（也就是从内存方面限制了线程数） 第二个限制自然是在JVM，理论上我们能分配给线程的内存除以单个线程占用的内存就是最大线程数。所以说对Java进程来讲，既然分配给了堆，栈和静态方法区（或叫永久代，perm区），我们可以大致认为 1线程数 = （系统空闲内存-堆内存（-Xms, -Xmx）- perm区内存(-XX:MaxPermSize)) / 线程栈大小(-Xss) 注意这只是帮助我们树立一个概念，实际上还有许多因素影响。 栈的大小还影响到一个就是如果单个栈超过了这个大小，就会抛出StackOverflowError，一般来说递归调用是常见的原因。 使用命令jstack &lt;pid&gt;可以列出当前pid对应jvm的所有线程栈描述，描述主要包括了每个线程的状态以及堆栈内各栈帧的方法全限定名，代码位置。注意这只是为了可阅读性，并不是说栈里存着的就是这些字符串。 栈帧 栈帧由局部变量区、操作数栈和帧数据区组成。当虚拟机调用一个Java方法时，它从对应类的类型信息中得到此方法的局部变量区和操作数栈的大小，并根据此分配栈帧内存，然后压入Java栈中。 局部变量区 局部变量区被组织为以字长为单位、从0开始计数的数组。字节码指令通过从0开始的索引使用其中的数据。类型为int, float, reference和returnAddress的值在数组中占据一项，而类型为byte, short和char的值在存入数组前都被转换为int值，也占据一项。但类型为long和double的值在数组中却占据连续的两项。 img 操作数栈 和局部变量区一样，操作数栈也是被组织成一个以字长为单位的数组。它通过标准的栈操作访问–压栈和出栈。由于程序计数器无法被程序指令直接访问，Java虚拟机的指令是从操作数栈中取得操作数，所以它的运行方式是基于栈而不是基于寄存器。虚拟机把操作数栈作为它的工作区，因为大多数指令都要从这里弹出数据，执行运算，然后把结果压回操作数栈。 帧数据区 除了局部变量区和操作数栈，Java栈帧还需要帧数据区来支持常量池解析、正常方法返回以及异常派发机制。每当虚拟机要执行某个需要用到常量池数据的指令时，它会通过帧数据区中指向常量池的指针来访问它。除了常量池的解析外，帧数据区还要帮助虚拟机处理Java方法的正常结束或异常中止。如果通过return正常结束，虚拟机必须恢复发起调用的方法的栈帧，包括设置程序计数器指向发起调用方法的下一个指令；如果方法有返回值，虚拟机需要将它压入到发起调用的方法的操作数栈。为了处理Java方法执行期间的异常退出情况，帧数据区还保存一个对此方法异常表的引用。 程序计数器 对于一个运行中的Java程序而言，每一个线程都有它的程序计数器。程序计数器也叫PC寄存器。程序计数器既能持有一个本地指针，也能持有一个returnAddress。当线程执行某个Java方法时，程序计数器的值总是下一条被执行指令的地址。这里的地址可以是一个本地指针，也可以是方法字节码中相对该方法起始指令的偏移量。 程序计数器（Program Counter Register）是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的行号指示器。在虚拟机的概念模型里（仅是概念模型，各种虚拟机可能会通过一些更高效的方式去实现），字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。由于Java 虚拟机的多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何一个确定的时刻，一个处理器（对于多核处理器来说是一个内核）只会执行一条线程中的指令。因此，为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各条线程之间的计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。如果线程正在执行的是一个Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是Natvie 方法，这个计数器值则为空（Undefined）。此内存区域是唯一一个在Java 虚拟机规范中没有规定任何OutOfMemoryError 情况的区域。 本地方法栈 任何本地方法接口都会使用某种本地方法栈。当线程调用Java方法时，虚拟机会创建一个新的栈帧并压入Java栈。当它调用的是本地方法时，虚拟机会保持Java栈不变，不再在线程的Java栈中压入新的栈，虚拟机只是简单地动态连接并直接调用指定的本地方法。 其中方法区和堆由该虚拟机实例中所有线程共享。当虚拟机装载一个class文件时，它会从这个class文件包含的二进制数据中解析类型信息，然后把这些类型信息放到方法区。当程序运行时，虚拟机会把所有该程序在运行时创建的对象放到堆中。像其它运行时内存区一样，本地方法栈占用的内存区可以根据需要动态扩展或收缩。 本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，其区别不过是虚拟机栈为虚拟机执行Java 方法（也就是字节码）服务，而本地方法栈则是为虚拟机使用到的Native 方法服务。虚拟机规范中对本地方法栈中的方法使用的语言、使用方式与数据结构并没有强制规定，因此具体的虚拟机可以自由实现它。甚至有的虚拟机（譬如Sun HotSpot 虚拟机）直接就把本地方法栈和虚拟机栈合二为一。与虚拟机栈一样，本地方法栈区域也会抛出StackOverflowError 和OutOfMemoryError异常。 直接内存 直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现，所以我们放到这里一起讲解。在JDK 1.4 中新加入了NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的I/O 方式，它可以使用Native 函数库直接分配堆外内存，然后通过一个存储在Java 堆里面的DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和Native 堆中来回复制数据。显然，本机直接内存的分配不会受到Java 堆大小的限制，但是，既然是内存，则肯定还是会受到本机总内存（包括RAM 及SWAP 区或者分页文件）的大小及处理器寻址空间的限制。服务器管理员配置虚拟机参数时，一般会根据实际内存设置-Xmx等参数信息，但经常会忽略掉直接内存，使得各个内存区域的总和大于物理内存限制（包括物理上的和操作系统级的限制），从而导致动态扩展时出现OutOfMemoryError异常。 执行引擎 在Java虚拟机规范中，执行引擎的行为使用指令集定义。实现执行引擎的设计者将决定如何执行字节码，实现可以采取解释、即时编译或直接使用芯片上的指令执行，还可以是它们的混合。 执行引擎可以理解成一个抽象的规范、一个具体的实现或一个正在运行的实例。抽象规范使用指令集规定了执行引擎的行为。具体实现可能使用多种不同的技术–包括软件方面、硬件方面或树种技术的结合。作为运行时实例的执行引擎就是一个线程。 运行中Java程序的每一个线程都是一个独立的虚拟机执行引擎的实例。从线程生命周期的开始到结束，它要么在执行字节码，要么执行本地方法。 指令集 方法的字节码流由Java虚拟机的指令序列构成。每一条指令包含一个单字节的操作码，后面跟随0个或多个操作数。操作码表示需要执行的操作；操作数向Java虚拟机提供执行操作码需要的额外信息。当虚拟机执行一条指令时，可能使用当前常量池中的项、当前帧的局部变量中的值或者位于当前帧操作数栈顶端的值。 抽象的执行引擎每次执行一条字节码指令。Java虚拟机中运行的程序的每个线程（执行引擎实例）都执行这个操作。执行引擎取得操作码，如果操作码有操作数，就取得它的操作数。它执行操作码和跟随的操作数规定的动作，然后再取得下一个操作码。这个执行字节码的过程在线程完成前将一直持续，通过从它的初始方法返回，或者没有捕获抛出的异常都可以标志着线程的完成。 本地方法接口 Java本地接口，也叫JNI（Java Native Interface），是为可移植性准备的。本地方法接口允许本地方法完成以下工作： 传递或返回数据 操作实例变量 操作类变量或调用类方法 操作数组 对堆的对象加锁 装载新的类 抛出异常 捕获本地方法调用Java方法抛出的异常 捕获虚拟机抛出的异步异常 指示垃圾收集器某个对象不再需要 对象创建过程 逻辑内存模型我们已经看到了，那当我们建立一个对象的时候是怎么进行访问的呢？ 在Java 语言中，对象访问是如何进行的？对象访问在Java 语言中无处不在，是最普通的程序行为，但即使是最简单的访问，也会却涉及Java 栈、Java 堆、方法区这三个最重要内存区域之间的关联关系，如下面的这句代码：Object obj = new Object();假设这句代码出现在方法体中，那“Object obj”这部分的语义将会反映到Java 栈的本地变量表中，作为一个reference 类型数据出现。而“new Object()”这部分的语义将会反映到Java 堆中，形成一块存储了Object 类型所有实例数据值（Instance Data，对象中各个实例字段的数据）的结构化内存，根据具体类型以及虚拟机实现的对象内存布局（Object Memory Layout）的不同，这块内存的长度是不固定的。另外，在Java 堆中还必须包含能查找到此对象类型数据（如对象类型、父类、实现的接口、方法等）的地址信息，这些类型数据则存储在方法区中。由于reference 类型在Java 虚拟机规范里面只规定了一个指向对象的引用，并没有定义这个引用应该通过哪种方式去定位，以及访问到Java 堆中的对象的具体位置，因此不同虚拟机实现的对象访问方式会有所不同，主流的访问方式有两种：使用句柄和直接指针。如果使用句柄访问方式，Java 堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息，如下图所示。 如果使用直接指针访问方式，Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，reference 中直接存储的就是对象地址，如下图所示 这两种对象的访问方式各有优势，使用句柄访问方式的最大好处就是reference 中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference 本身不需要被修改。使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。就本书讨论的主要虚拟机Sun HotSpot 而言，它是使用第二种方式进行对象访问的，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。 参考资料 https://www.cnblogs.com/lao-liang/p/5110710.html https://www.cnblogs.com/dingyingsi/p/3760447.html https://www.jianshu.com/p/c9ac99b87d56]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>虚拟机</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>jvm</tag>
        <tag>java虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[zookeeper基本原理及适用场景]]></title>
    <url>%2Fposts%2F21319.html</url>
    <content type="text"><![CDATA[zookeeper基本原理及适用场景 随着企业业务的越来越复杂、庞大，用户对系统性能越来越高的要求，拆分系统是目前我们可选择的解决系统可伸缩性和性能问题的唯一行之有效的方法。但是拆分系统同时也带来了系统的复杂性——各子系统不是孤立存在的，它们彼此之间需要协作和交互，这就是我们常说的分布式系统。为了使各个子系统能正常为用户提供统一的服务，必须要要一种机制来进行协调。而提供这些分布式环境下非常重要也是非常基础服务的关键性组件，就是zookeeper。 zookeeper简介 Zookeeper 是 Hadoop 生态系统中的协同实现，是Hadoop集群管理的一个必不可少的模块，它主要来控制集群中的数据，如它管理Hadoop集群中的NameNode，还有Hbase中Master Election、Server之间状态同步等。Zookeeper 实际上是 Google 的 Chubby 一个开源的实现。Zookeeper 的配置中心实现更像一个文件系统，文件系统中的所有文件形成一个树状结构。Zookeeper 维护着这样的树形层次结构，树中的节点称为 Znode, 每个 Znode 存储的数据有小于 1m 的大小限制。zookeeper 对 Znode 提供了几种类型：临时 Znode、持久 Znode、顺序 node 等几种类型，用于不同的一致性需求。在 Znode 发生变化时，通过“观察”（watch）机制可以让客户端得到通知。可以针对 Zookeeper 服务的“操作”来设置观察，该服务的其他操作可以触发观察。Zookeeper 服务的“操作”包括一些对 Znode 添加修改获取操作。Zookeeper 采用一种类似 Paxos 的算法实现领导者选举，用于解决集群宕机的一致性和协同保障。总体上，Zookeeper 提供了一个分布式协同系统，包括配置维护、名字服务、分布式同步、组服务等功能，并将相关操作接口提供给用户。 zookeeper架构 Zookeeper 从设计模式角度来看，是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在 Zookeeper 上注册的那些观察者做出相应的反应，从而实现集群中类似 Master/Slave 管理模式。 Zookeeper数据结构的特点 每个子目录项如 NameService 都被称作为 Znode，这个 Znode 是被它所在的路径唯一标识，如Server1 这个 Znode 的标识为 /NameService/Server1； Znode 可以有子节点目录，并且每个 Znode 可以存储数据，注意 EPHEMERAL 类型的目录节点不能有子节点目录(因为它是临时节点)； Znode 是有版本的，每个 Znode 中存储的数据可以有多个版本，也就是一个访问路径中可以存储多份数据； Znode 可以是临时节点，一旦创建这个 Znode 的客户端与服务器失去联系，这个 Znode 也将自动删除，Zookeeper 的客户端和服务器通信采用长连接方式，每个客户端和服务器通过心跳来保持连接，这个连接状态称为 session，如果 Znode 是临时节点，这个 session 失效，Znode 也就删除了 Znode 的目录名可以自动编号，如 App1 已经存在，再创建的话，将会自动命名为 App2 Znode 可以被监控，包括这个目录节点中存储的数据的修改，子节点目录的变化等，一旦变化可以通知设置监控的客户端，这个是 Zookeeper 的核心特性。 Znode的节点类型 在 ZooKeeper 中，节点类型可以分为持久节点（PERSISTENT ）、临时节点（EPHEMERAL），以及时序节点（SEQUENTIAL ），具体在节点创建过程中，一般是组合使用，可以生成以下 4 种节点类型。 持久节点（PERSISTENT） 所谓持久节点，是指在节点创建后，就一直存在，直到有删除操作来主动清除这个节点——不会因为创建该节点的客户端会话失效而消失。 持久顺序节点（PERSISTENT_SEQUENTIAL） 这类节点的基本特性和上面的节点类型是一致的。额外的特性是，在ZK中，每个父节点会为他的第一级子节点维护一份时序，会记录每个子节点创建的先后顺序。基于这个特性，在创建子节点的时候，可以设置这个属性，那么在创建节点过程中，ZK会自动为给定节点名加上一个数字后缀，作为新的节点名。这个数字后缀的范围是整型的最大值。 临时节点（EPHEMERAL） 和持久节点不同的是，临时节点的生命周期和客户端会话绑定。也就是说，如果客户端会话失效，那么这个节点就会自动被清除掉。注意，这里提到的是会话失效，而非连接断开。另外，在临时节点下面不能创建子节点。 临时顺序节点（EPHEMERAL_SEQUENTIAL） 可以用EPHEMERAL_SEQUENTIAL来实现分布式锁 客户端调用create()方法创建名为“locknode/guid-lock-”的节点，需要注意的是，这里节点的创建类型需要设置为EPHEMERAL_SEQUENTIAL。 客户端调用getChildren(&quot;_locknode_&quot;)方法来获取所有已经创建的子节点，注意，这里不注册任何Watcher。 客户端获取到所有子节点path之后，如果发现自己在步骤1中创建的节点序号最小，那么就认为这个客户端获得了锁。 如果在步骤3中发现自己并非所有子节点中最小的，说明自己还没有获取到锁。此时客户端需要找到比自己小的那个节点，然后对其调用exist()方法，同时注册事件监听。 之后当这个被关注的节点被移除了，客户端会收到相应的通知。这个时候客户端需要再次调用getChildren(&quot;_locknode_&quot;)方法来获取所有已经创建的子节点，确保自己确实是最小的节点了，然后进入步骤3。 zookeeper使用场景 统一命名服务（Name Service） 分布式应用中，通常需要有一套完整的命名规则，既能够产生唯一的名称又便于人识别和记住，通常情况下用树形的名称结构是一个理想的选择，树形的名称结构是一个有层次的目录结构，既对人友好又不会重复。Name Service 已经是 Zookeeper 内置的功能，你只要调用 Zookeeper 的 API 就能实现。如调用 create 接口就可以很容易创建一个目录节点。 例如有一组服务器向客户端提供某种服务，我们希望客户端每次请求服务端都可以找到服务端集群中某一台服务器，这样服务端就可以向客户端提供客户端所需的服务。对于这种场景，我们的程序中一定有一份这组服务器的列表，每次客户端请求时候，都是从这份列表里读取这份服务器列表。那么这分列表显然不能存储在一台单节点的服务器上，否则这个节点挂掉了，整个集群都会发生故障，我们希望这份列表时高可用的。高可用的解决方案是：这份列表是分布式存储的，它是由存储这份列表的服务器共同管理的，如果存储列表里的某台服务器坏掉了，其他服务器马上可以替代坏掉的服务器，并且可以把坏掉的服务器从列表里删除掉，让故障服务器退出整个集群的运行，而这一切的操作又不会由故障的服务器来操作，而是集群里正常的服务器来完成。这是一种主动的分布式数据结构，能够在外部情况发生变化时候主动修改数据项状态的数据机构。Zookeeper框架提供了这种服务。这种服务名字就是：统一命名服务。 配置管理（Configuration Management） 配置的管理在分布式应用环境中很常见，例如同一个应用系统需要多台 PC Server 运行，但是它们运行的应用系统的某些配置项是相同的，如果要修改这些相同的配置项，那么就必须同时修改每台运行这个应用系统的 PC Server，这样非常麻烦而且容易出错。像这样的配置信息完全可以交给 Zookeeper 来管理，将配置信息保存在 Zookeeper 的某个目录节点中，然后将所有需要修改的应用机器监控配置信息的状态，一旦配置信息发生变化，每台应用机器就会收到 Zookeeper 的通知，然后从 Zookeeper 获取新的配置信息应用到系统中。zookeeper服务也会保证同步操作原子性（要么成功同步成功，要么失败），确保每个服务器的配置文件都能被正确的更新。 注：百度的分布式配置系统disconf就是基于zookeeper的这个服务来完成配置的实时更新的。 集群管理（Group Membership） Zookeeper 能够很容易的实现集群管理的功能，如有多台 Server 组成一个服务集群，那么必须要一个master知道当前集群中每台机器的服务状态，一旦有机器不能提供服务，集群中其它节点必须知道，从而做出调整重新分配服务策略。同样当增加集群的服务能力时，就会增加一台或多台 Server，同样也必须让master知道。Zookeeper 不仅能够帮你维护当前的集群中机器的服务状态，而且能够帮你选出一个master，让这个master来管理集群，这就是 Zookeeper 的另一个功能 Leader Election。 它们的实现方式都是在 Zookeeper 上创建一个 EPHEMERAL 类型的目录节点，然后每个 Server 在它们创建目录节点的父目录节点上调用getChildren(String path, boolean watch) 方法并设置 watch 为true，由于是 EPHEMERAL 目录节点，当创建它的 Server 死去，这个目录节点也随之被删除，所以Children 将会变化，这时 getChildren上的 Watch 将会被调用，所以其它 Server 就知道已经有某台Server 死去了。新增 Server 也是同样的原理。 Zookeeper 如何实现 Leader Election，也就是选出一个 Master Server。和前面的一样每台 Server 创建一个 EPHEMERAL 目录节点，不同的是它还是一个 SEQUENTIAL 目录节点，所以它是个EPHEMERAL_SEQUENTIAL 目录节点。之所以它是 EPHEMERAL_SEQUENTIAL 目录节点，是因为我们可以给每台 Server 编号，我们可以选择当前是最小编号的 Server 为 Master，假如这个最小编号的Server 死去，由于是 EPHEMERAL 节点，死去的 Server 对应的节点也被删除，所以当前的节点列表中又出现一个最小编号的节点，我们就选择这个节点为当前 Master。这样就实现了动态选择 Master，避免了传统意义上单 Master 容易出现单点故障的问题。 注：关于zookeeper的选举算法，可以参考《从PAXOS到ZOOKEEPER分布式一致性原理与实践》一书 共享锁（Locks） 共享锁在同一个进程中很容易实现，但是在跨进程或者在不同 Server 之间就不好实现了。Zookeeper 却很容易实现这个功能，实现方式也是需要获得锁的 Server 创建一个 EPHEMERAL_SEQUENTIAL 目录节点，然后调用 getChildren方法获取当前的目录节点列表中最小的目录节点是不是就是自己创建的目录节点，如果正是自己创建的，那么它就获得了这个锁，如果不是那么它就调用 exists(String path, boolean watch) 方法并监控 Zookeeper 上目录节点列表的变化，一直到自己创建的节点是列表中最小编号的目录节点，从而获得锁，释放锁很简单，只要删除前面它自己所创建的目录节点就行了。 当分布式系统操作数据，例如：读取数据、分析数据、最后修改数据。在分布式系统里这些操作可能会分散到集群里不同的节点上，那么这时候就存在数据操作过程中一致性的问题，如果不一致，我们将会得到一个错误的运算结果，在单一进程的程序里，一致性的问题很好解决，但是到了分布式系统就比较困难，因为分布式系统里不同服务器的运算都是在独立的进程里，运算的中间结果和过程还要通过网络进行传递，那么想做到数据操作一致性要困难的多。Zookeeper提供了一个锁服务解决了这样的问题，能让我们在做分布式数据运算时候，保证数据操作的一致性。 队列管理 Zookeeper 可以处理两种类型的队列： 同步队列：当一个队列的成员都聚齐时，这个队列才可用，否则一直等待所有成员到达，这种是同步队列。 同步队列用 Zookeeper 实现的实现思路如下： 创建一个父目录 /synchronizing，每个成员都监控标志（Set Watch）位目录 /synchronizing/start 是否存在，然后每个成员都加入这个队列，加入队列的方式就是创建 /synchronizing/member_i 的临时目录节点，然后每个成员获取 / synchronizing 目录的所有目录节点，也就是 member_i。判断 i 的值是否已经是成员的个数，如果小于成员个数等待 /synchronizing/start 的出现，如果已经相等就创建/synchronizing/start。 FIFO队列：先进先出队列，例如实现生产者和消费者模型。 FIFO 队列用 Zookeeper 实现思路如下： 实现的思路也非常简单，就是在特定的目录下创建 SEQUENTIAL 类型的子目录 /queue_i，这样就能保证所有成员加入队列时都是有编号的，出队列时通过 getChildren( ) 方法可以返回当前所有的队列中的元素，然后消费其中最小的一个，这样就能保证 FIFO。 本文参考：http://blog.chinaunix.net/uid-28240115-id-4251167.html]]></content>
      <categories>
        <category>技术</category>
        <category>架构</category>
        <category>分布式</category>
      </categories>
      <tags>
        <tag>分布式</tag>
        <tag>zookeeper基本原理</tag>
        <tag>zookeeper适用场景</tag>
        <tag>架构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[项目日志漫谈]]></title>
    <url>%2Fposts%2F5735.html</url>
    <content type="text"><![CDATA[项目日志漫谈 日志系统是任何系统都不可或缺的一部分，明白如何记录日志和应该记录什么是一个软件工程师必备的技能。但怎么样才能做好日志系统呢？ 记录日志的若干建议 查阅了很多资料，再结合自己的项目经验，大概可以给出以下几点建议。 不应该自己写日志系统 现在有很多流行的logging库，在Java里面有比如Log4j（log4j2），slf4j，logback，Apache Commons Logging等，它们都经受住了时间的考验，是非常可靠的日志系统（库）。关于各个库的性能问题，我们稍后再详细讨论，但可以肯定的是，它们肯定比你自己写日志系统靠谱的多。 推荐使用slf4j +log4j(log4j2)/logback来记录日志。 使用slf4j的原因是，SLF4J与上述其它的日志库之间有一个主要的区别。SLF4J或者说是Java的简单记录日志设计没有真正地实现日志记录，相反它只是一个允许你使用任何处于后端的日志记录库的抽象层 。如果你正在编写内部或者外部使用的API或者应用库的话，那么你真的不需要让使用你所编写的库的客户端还去选择日志库。假设项目已经使用了log4j，而且你包含一个名为Apache Active MQ的库，这个库还依赖于另一个日志记录库logback的话，那么你还需要包含它们，然而，如果Apache Active MQ使用了SLF4J的话，你可以继续使用你的日志记录库，而不需要痛苦地添加和维护新的日志记录框架。简短的说，SLF4J让你的代码独立于任何特定的日志记录API，这个好的想法尤其适合于公共的API开发人员。虽然日志记录库的抽象理念不是新的，而且Apache的commons logging日志记录库也是用了这个理念，不过现在SLF4J是Java世界里标准的日志记录库。让我们看一些使用 SLF4J而不使用log4j,logback或者java.util.logging的理由。 1）在你的开源库或者私有库中使用SLF4J，可以使它独立于任何的日志实现，这就意味着不需要管理多个库和多个日志文件。你的客户端将会体会到这一点。 2）SLF4J提供了占位日志记录，通过移除对isDebugEnabled(), isInfoEnabled()等等的检查提高了代码的可读性。 3）通过使用日志记录方法，直到你使用到的时候，才会去构造日志信息（字符串），这就同时提高了内存和CPU的使用率。 4）做一个侧面的说明，越少的临时字符串，垃圾回收器就意味着越少的工作，这就意味着为你的应用程序提供更好的吞吐量和性能。 在适当级别上记录日志 尽管我们有多个日志库可供选择，但是在记录日志时都要遵循一个普遍的原则：在适当的级别傻姑娘记录日志。下面给出一个比较通用的建议。 TRACE level： 一般用在开发环境中，用于开发过程中追踪问题。 DEBUG level：可以把一切东西都记录在这里。这在调试过程中最常用到。在进入生产阶段前减少debug语句的数量，只留下最有意义的部分。 INFO level: 记录一些比较有价值的用户行为(user-driven)和系统的特定行为(例如计划任务…)，但是这样的信息不宜太多。 NOTICE level：这是生产环境中使用的级别。把一切不认为是错误的，可以记录的事件都log起来 WARN level：记录在这个级别的事件都有可能成为一个error。例如，一次调用数据库使用的时间超过了预设时间，或者内存缓存即将到达容量上限。这可以让你适当地发出警报，或者在调试时更好地理解系统在failure之前做了些什么 ERROR level：把每一个错误条件都记录在这。例如API调用返回了错误，或是内部错误条件 FATAL level：极少被用到，在实际程序中也不应该出现多少。在这个级别上进行log意味着程序要结束了。例如一个网络守护进程无法bind到socket上，那么它唯一能做的就只有log到这里，然后退出运行。 测试联调环境一般的都是用DEBUG level，因为可以获取到任何自己感兴趣的信息，正式的生产环境可以用INFO level，只记录一些重要的信息，当然也有的系统会用到WARN level。当然如果在生产环境出现了一个bug，仅靠INFO level或者WARN level，ERROR level无法定位问题的话，可能你会想看到debug级别的日志，帮助排查问题，这个就涉及到动态调整系统的日志级别了，我们稍后再说。 将日志信息分类 大部分的日志库允许指定一个日志类别以及将不同类别的日志记录到不同的文件中去。它可以分类log信息，并基于logging框架的配置，在最后以某一形式进行记录。比如将日志分为业务日志、错误日志和系统日志等，并将它们按照统一的格式进行输出，使得排查问题时可以一目了然的看出是哪个文件在什么时间点发生了什么，如果是错误日志的话，最好是打印出行号和错误原因。 1234567891011&lt;RollingRandomAccessFile name="smartrobotLog" fileName="logs/biz.log" filePattern="logs/$$&#123;date:yyyy-MM&#125;/biz-%d&#123;MM-dd-yyyy&#125;-%i.log"&gt; &lt;Append&gt;true&lt;/Append&gt; &lt;PatternLayout pattern="%d&#123;yy-MM-dd.HH:mm:ss.SSS&#125; [%-16t] %-5p %-22c&#123;0&#125; - [%X&#123;traceId&#125;] - %m%n" /&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval="1" modulate="true" /&gt; &lt;SizeBasedTriggeringPolicy size="500 MB"/&gt; &lt;/Policies&gt; &lt;/RollingRandomAccessFile&gt; 上面的一段log4j的配置代码指定了日志输出的格式以及日志文件归档的策略。 如果对log4j的语法不熟悉的话，可以参考http://www.cnblogs.com/elaron/archive/2013/01/14/2860259.html 这篇博客。 写有意义的log 这可能是最重要的建议了。没有什么比你深刻理解程序内部，却写出含糊的日志更糟了。 在你写日志信息之前，总要提醒自己，有突发事件的时候，你唯一拥有的只有来自log文件，你必须从中明白发生了什么。一个很有用的日志内容是接口（无论是自己提供的接口还是调用其它系统的接口）的入参、返回值，如果是调用外部接口的话，最好把完整的请求url及返回的原始结果打印出来。 在写warn和error level时尤为重要的一个方法是，添加辅助信息到log信息中，如果做不到，那么改为把这个操作的作用写下。 还有，不要让一个log信息的内容基于上一个。这是因为前面的信息可能由于(与当前信息)处于不同的类别或者level而没被写入。更坏的情况是，它因多线程或异步操作，在另一个地方(或是以另一方式)出现。 为你的日志增加traceId 一个很有用的关于日志的纪录是traceId（基于线程，可追踪一条业务线），尤其是分布式系统中。如果使用的是log4j或者是logback的话，可以结合slf4j的MDC来为线程统一的添加traceId，可以添加到AOP或Filter或Interceptor中。如下： 12345678910111213@Around(value = "execution(* com.xx.xx.facade.impl.*.*(..))", argNames="pjp") public Object validator(ProceedingJoinPoint pjp) throws Throwable &#123; try &#123; String traceId = TraceUtils.begin(); MDC.put("traceId", traceId); Object obj = pjp.proceed(args); return obj; &#125; catch(Throwable e) &#123; //TODO 处理错误 &#125; finally &#123; TraceUtils.endTrace(); &#125; &#125; 代码通过AOP记录了每次请求的traceId并使用变量“mdc_trace_id”记录，在日志配置文件里需要设置变量才能将“traceId”输出到日志文件中。我以logback配置文件为例,看日志第6行%X{traceId}： 1234567891011&lt;RollingRandomAccessFile name="smartrobotLog" fileName="logs/biz.log" filePattern="logs/$$&#123;date:yyyy-MM&#125;/biz-%d&#123;MM-dd-yyyy&#125;-%i.log"&gt; &lt;Append&gt;true&lt;/Append&gt; &lt;PatternLayout pattern="%d&#123;yy-MM-dd.HH:mm:ss.SSS&#125; [%-16t] %-5p %-22c&#123;0&#125; - [%X&#123;traceId&#125;] - %m%n" /&gt; &lt;Policies&gt; &lt;TimeBasedTriggeringPolicy interval="1" modulate="true" /&gt; &lt;SizeBasedTriggeringPolicy size="500 MB"/&gt; &lt;/Policies&gt; &lt;/RollingRandomAccessFile&gt; 当然利用MDC我们还可以添加很多其它有用的信息。总结下MDC为我们带来的好处： 如果你的系统已经上线，突然有一天老板说我们增加一些用户数据到日志里分析一下。如果没有MDC我猜此时此刻你应该处于雪崩状态。MDC恰到好处的让你能够实现在日志上突如其来的一些需求 如果你是个代码洁癖，封装了公司LOG的操作，并且将处理线程跟踪日志号也封装了进去，但只有使用了你封装日志工具的部分才能打印跟踪日志号，其他部分(比如hibernate、mybatis、httpclient等等)日志都不会体现跟踪号。当然我们可以通过linux命令来绕过这些困扰。 使代码简洁、日志风格统一 应该用机器可解析的格式来打日志 日志是给人看的，但有时候当数量量很大的情况下，靠人肉去分析log就不太现实了，一定要自动化的去分析日志。如果我们想要顺利的实现日志分析的自动化，那么用机器容易解析的格式记录日志就很有必要了。 举个例子。 1log.info("User &#123;&#125; plays &#123;&#125; in game &#123;&#125;",userId,card，gameId); 它会生成类似如下的输出： 12017-10-1217:49:37,656[T1]INFOc.d.g.UserRequestUser1334563plays4ofspadesingame23425656 如果我们想自动化解析它的话，就比较麻烦了/User(\d+)plays(.+)ingame(\d+)$/ 正则表达式是一个可行的方案，但是这并不轻松而且容易出错。一个更好的解决方案是把log记录成机器容易解析的格式，比如JSON。 12017-10-1217:49:37,656[T1]INFOc.d.g.UserRequestUserplays&#123;&apos;user&apos;:1334563,&apos;card&apos;:&apos;4ofspade&apos;,&apos;game&apos;:23425656&#125; 现在你的log分析器可以更容易地写入，更直接地索引，而且你可以释放logstash（如果日志最终是放在logstash）所有的威力。 将日志收集到日志聚合系统 说到日志分析，就不得不提日志聚合系统。现在主流的日志分析系统有logstash和flume。关于它们具体的区别请自己百度，这样的文章很多。但是使用日志聚合系统总的目的是为了分析日志，还可以解决分布式环境下日志分散的问题。 应该考虑阅读者 为什么要对应用程序做日志？ 唯一的答案是，在某一天会有人去读它(或是它的意义)。更重要的是，猜猜谁会读它，这是很有趣的事。对于不同的”谁”，你将要写下的log信息的内容，上下文，类别和level会大不同。 这些”谁”包括: 一个尝试自己解决问题的终端用户(想象一个客户端或桌面程序) 一个在调试产品问题的系统管理员或者运维工程师 一个在开发中debug，或者在解决产品问题的开发者 开发者了解程序内部，所以给他的log信息可以比给终端用户的复杂得多。为你的目标阅读者调整你的表达方式，乃至为此加入额外的类别(dedicate separate catagories)。 当然，不管目标读者是谁，请记得给你的日志带上上下文。这一点可以配合前面提到的MDC来完成。、 给日志添加监控 可以给log4j日志添加邮件提醒，当出现ERROR级别的错误时发送邮件给相关技术人员。当然，如果你有专门的监控系统，这点可以忽略。 123456789101112131415161718## MAILlog4j.appender.MAIL=org.apache.log4j.net.SMTPAppender# 日志的错误级别log4j.appender.MAIL.Threshold=ERROR #缓存文件大小，日志达到512K时发送Emaillog4j.appender.MAIL.BufferSize=512# 发送邮件的服务器log4j.appender.MAIL.SMTPHost=smtp.163.com# 邮件的标题log4j.appender.MAIL.Subject=Log4J ErrorMessage# 用户名log4j.appender.MAIL.SMTPUsername=邮箱用户名# 密码log4j.appender.MAIL.SMTPPassword=邮箱密码# 发件人地址log4j.appender.MAIL.From=test@163.com # 日志邮件的接收者log4j.appender.MAIL.To=test@163.com 流行日志库的性能对比 关于性能对比，可以参考这篇博客 https://blog.souche.com/logback-log4j-log4j2shi-ce/ 。 这里只说下结果。 实验环境 OS: Mac OS X 10.12.1 CPU: 2.6 GHz Intel Core i5 内存: 8 GB 1600 MHz DDR3 实验结果 logback log4j log4j2性能对比 可见在同步日志模式下, Logback的性能是最糟糕的. 而log4j2的性能无论在同步日志模式还是异步日志模式下都是最佳的. 其根本原因在于log4j2使用了LMAX，一个无锁的线程间通信库代替了, logback和log4j之前的队列. 并发性能大大提升。 关于log4j2的新特性 丢数据这种情况少，可以用来做审计功能。而且自身内部报的exception会被发现，但是logback和log4j不会。 log4j2使用了disruptor技术，在多线程环境下，性能高于logback等10倍以上。 (garbage free）之前的版本会产生非常多的临时对象，会造成GC频繁，log4j2则在这方面上做了优化，减少产生临时对象。尽可能少的GC 利用插件系统，使得扩展新的appender,filter,layout等变得容易，log4j不可以扩展 插件？？？？ 因为插件系统的简单性，所以在配置的时候，可以不用具体指定所要处理的类型。class 可以自定义level Java 8 lambda support for lazy logging Support for Message objects 对filter的功能支持的更强大 系统日志(Syslog)协议supports both TCP and UDP 利用jdk1.5并发的特性，减少了死锁的发生。 Socket LogEvent SerializedLayout 支持kafka queue 动态更新log4j的日志级别 项目上线了后，我们生产环境一般设置的输出级别都是INFO，但是有些问题不一定能通过INFO信息找到。如何能做到 动态的修改日志的级别，而且不用重启服务，对线上环境的影响减少到最小呢？ 首先POM中加上这些依赖： 12345678910111213141516171819202122232425262728293031&lt;properties&gt; &lt;spring_version&gt;3.2.2.RELEASE&lt;/spring_version&gt;&lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-api&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.slf4j&lt;/groupId&gt; &lt;artifactId&gt;slf4j-log4j12&lt;/artifactId&gt; &lt;version&gt;1.6.2&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;log4j&lt;/groupId&gt; &lt;artifactId&gt;log4j&lt;/artifactId&gt; &lt;version&gt;1.2.16&lt;/version&gt; &lt;/dependency&gt; &lt;!-- spring --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring_version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 然后在项目的web.xml中加上: 1234567891011121314&lt;!--由Sprng载入的Log4j配置文件位置--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jConfigLocation&lt;/param-name&gt; &lt;param-value&gt;/WEB-INF/classes/log4j.properties&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring默认刷新Log4j配置文件的间隔,单位为millisecond--&gt; &lt;context-param&gt; &lt;param-name&gt;log4jRefreshInterval&lt;/param-name&gt; &lt;param-value&gt;6000&lt;/param-value&gt; &lt;/context-param&gt; &lt;!--Spring log4j 监听器--&gt; &lt;listener&gt; &lt;listener-class&gt;org.springframework.web.util.Log4jConfigListener&lt;/listener-class&gt; &lt;/listener&gt; 如上配置的作用是每隔6000毫秒扫描一次log4j配置文件的变化。 最后，需要在log4j的配置文件里面加上日志级别控制。 123&lt;root level="$&#123;log_level&#125;"&gt; &lt;appender-ref ref="$&#123;log_appender&#125;" /&gt;&lt;/root&gt; 而这里的log_level可以配合disconf或者类似的配置系统实现实时的修改日志级别。 本文参考 http://blog.jobbole.com/52018/ ， https://blog.souche.com/logback-log4j-log4j2shi-ce/]]></content>
      <categories>
        <category>技术</category>
        <category>架构</category>
        <category>日志</category>
      </categories>
      <tags>
        <tag>java日志</tag>
        <tag>日志系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java事件机制浅析]]></title>
    <url>%2Fposts%2F42720.html</url>
    <content type="text"><![CDATA[Java事件机制浅析 Java的事件机制最初是用在Swing组件上的，用来处理诸如按钮按下之类的动作事件，但如果理解了事件机制的基本概念，我们可以轻易的将其用到任何Java对象上。 基本概念 事件 事件可以是系统中发生的任何动作。 当一个事件发生时，该事件用一个事件对象来表示。事件对象有对应的事件类。 事件源 事件最初发生的地方。 事件处理器（事件处理方法） 事件处理器是一个接收事件对象并进行相应处理的方法。事件处理器包含在一个类中，这个类的对象负责检查事件是否发生，若发生就激活事件处理器进行处理。 注册事件监听器 为了能够让事件监听器检查事件源是否发生了某些事件，并且在发生时激活事件处理器进行相应的处理，必须在事件源上注册事件监听器。 实现Java事件机制 先介绍下Java中和事件处理相关的几个类，然后我们通过一个简单的实例来详细了解。 涉及到的Java类 Java的事件机制一般包括三个部分：EventObject，EventListener和Source。 EventObject java.util.EventObject是事件状态对象的基类，它封装了事件源对象以及和事件相关的信息。所有java的事件类都需要继承该类。 EventListener java.util.EventListener是一个标记接口，就是说该接口内是没有任何方法的。所有事件监听器都需要实现该接口。事件监听器注册在事件源上，当事件源的属性或状态改变的时候，调用相应监听器内的回调方法。 Source 事件源不需要实现或继承任何接口或类，它是事件最初发生的地方。因为事件源需要注册事件监听器，所以事件源内需要有相应的盛放事件监听器的容器。 实例 事件对象 1234567891011121314151617import java.util.EventObject;public class MyEvent extends EventObject &#123; private static final long serialVersionUID = 1L; private int sourceState; public MyEvent(Object source) &#123; super(source);//source为实际的事件对象(数据) sourceState = ((Source)source).getFlag(); &#125; public int getSourceState() &#123; return sourceState; &#125;&#125; 事件监听器 12345678910import java.util.EventListener;public class StateChangeListener implements EventListener &#123; public void handleEvent(MyEvent event) &#123; System.out.println("触发状态改变事件。。。"); System.out.println("当前事件源状态为：" + event.getSourceState()); System.out.println("。。。。。。。。。。。。。。。。。。。。。。。"); &#125;&#125; 1234567891011import java.util.EventListener;public class StateChangeToOneListener implements EventListener &#123; public void handleEvent(MyEvent event) &#123; System.out.println("触发状态变为1的事件。。。"); System.out.println("当前事件源状态为：" + event.getSourceState()); System.out.println("。。。。。。。。。。。。。。。。。。。。。。。"); &#125; &#125; 事件源 123456789101112131415161718192021222324252627282930313233343536373839404142434445import java.util.EventListener;import java.util.HashSet;import java.util.Set;public class Source &#123; private int flag = 0; Set&lt;EventListener&gt; listeners = new HashSet&lt;EventListener&gt;(); /** * 注册事件监听器 * * @param listener */ public void addListener(EventListener listener) &#123; listeners.add(listener); &#125; /** * 当事件发生时，通知注册在事件源上的所有事件做出相应的反映 */ public void notifyListener() &#123; for (EventListener listener : listeners) &#123; try &#123; ((StateChangeListener)listener).handleEvent(new MyEvent(this)); &#125; catch (Exception e) &#123; if (flag == 1) &#123; ((StateChangeToOneListener)listener).handleEvent(new MyEvent(this)); &#125; &#125; &#125; &#125; /** * 改变状态 */ public void changeFlag() &#123; flag = (flag == 0 ? 1 : 0); notifyListener(); &#125; public int getFlag() &#123; return flag; &#125;&#125; 测试类 12345678910111213141516public class Test &#123; public static void main(String[] args) &#123; Source source = new Source(); source.addListener(new StateChangeListener()); source.addListener(new StateChangeToOneListener()); source.changeFlag(); System.out.println("————————————————————————"); source.changeFlag(); System.out.println("～～～～～～～～～～～～～"); source.changeFlag(); &#125;&#125;]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>Java Core</category>
      </categories>
      <tags>
        <tag>Java Core</tag>
        <tag>Java事件机制</tag>
        <tag>swing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java异常处理体系详解]]></title>
    <url>%2Fposts%2F60571.html</url>
    <content type="text"><![CDATA[Java异常处理体系详解 异常指程序中不期而至的各种状况，如：文件找不到、网络连接失败、非法参数等。在Java中异常被当作是对象处理，所有的异常都基于一个超类：Throwable。本文主要讲解Java语言中的异常处理体系。 Java异常处理体系 Java中所有的异常都始于一个基类Throwable。我们就从Throwable讲起。 Throwable中的常用方法 Throwable中定义了一些公共的方法，所有的异常类都可以使用。其中常用的方法： getCause()：返回抛出异常的原因。如果 cause 不存在或未知，则返回 null。 getMessage()：返回异常的消息信息。 printStackTrace()：对象的堆栈跟踪输出至错误输出流，作为字段System.err的值。 这些方法用于发生异常时获取异常和堆栈信息，帮助我们快速的定位排查问题。 Java异常体系结构 Java中的所有异常（各种Exception，Error）都是java.lang.Throwable超类的子类。这些异常分为两大类：Error和Exception。 Error是程序无法处理的错误，表示程序运行期间发生较严重的问题。比如OutOfMemoryError、ThreadDeath等。这些异常发生时， Java虚拟机（JVM）一般会选择线程终止。 Exception是程序本身可以处理的异常，这种异常分两大类运行时异常和非运行时异常。 程序中应当尽可能去处理这些异常。 运行时异常 运行时异常都是RuntimeException类及其子类异常，如 NullPointerException、 IndexOutOfBoundsException 等，这些异常是非检查异常，程序中可以选择捕获处理，也可以不处理。这些异常一般是由程序逻辑错误引起的，程序应该从逻辑角度尽可能避免这类异常的发生。 非运行时异常 非运行时异常是RuntimeException以外的异常，类型上都属于Exception类及其子类。 从程序语法角度讲是必须进行处理的异常，属于检查异常。如果不处理，程序就不能编译通过。 如IOException、SQLException等以及用户自定义的Exception异常，一般情况下不自定义检查异常。 Java整个异常体系结构图 如下，笔者整理了Java（基于jdk1.8）的整个异常体系结构，谨供读者参考。 Java异常体系 Java异常处理机制 在Java程序中，异常处理有两种机制：抛出异常、捕获异常。检查异常必须在程序中处理；非检查异常，程序中可以选择捕获处理，也可以不处理。 抛出异常 Java中我们通过throw、throws关键字来抛出异常。 throw关键字用于方法体内部，抛出一个Throwable类型的异常。如果抛出了检查异常， 则还应该在方法头部声明方法可能抛出的异常类型。该方法的调用者也必须检查处理抛出的异常。 如果所有方法都层层上抛获取的异常，最终JVM会进行处理，处理也很简单，就是打印异常消息和堆栈信息。 如果抛出的是Error或RuntimeException，则该方法的调用者可选择处理该异常。 throws关键字用于方法体外部的方法声明部分，用来声明方法可能会抛出某些异常。仅当抛出了检查异常， 该方法的调用者才必须处理或者重新抛出该异常。当方法的调用者无力处理该异常的时候，应该继续抛出， 而不是囫囵吞枣一般在catch块中打印一下堆栈信息做个勉强处理。 捕获异常 捕获异常用try、catch、finally关键字。 try、catch、finally三个语句块均不能单独使用，三者可以组成 try...catch...finally、 try...catch、 try...finally三种结构，catch语句可以有一个或多个，finally语句最多一个。 try、catch、finally三个代码块中变量的作用域为代码块内部，分别独立而不能相互访问。 如果要在三个块中都可以访问，则需要将变量定义到这些块的外面。 多个catch块时候，其参数类型必须按照从子类到父类顺序由上到下，否则会导致捕获的异常不够精确。因为catch一旦匹配到一个类型，就会忽略往后的catch。比如IOException必须放到Exception前面，否则编译器会报错。 小技巧： 因为finally代码块每次都要执行，我们通常会在finally中写一些清理资源的代码，但有时候这样写会有一些问题。比如： 12345678910111213141516171819private BufferedReader in;public void inputFile(String fileName) throws Exception &#123; try &#123; in = new BufferedReader(new FileReader(fileName)); &#125; catch (FileNotFoundException e) &#123; //文件没找到异常 throw e; &#125; catch (Exception e) &#123; try &#123; //如果成功打开文件，此时才需要关闭文件 in.close(); &#125; catch (IOException ioException) &#123; &#125; throw e; &#125; finally &#123; //不要在这里关闭文件，因为有可能这个文件根本就没有打开 &#125;&#125; 最安全的方法是实用嵌套的try子句。如下： 1234567891011121314151617181920private BufferedReader in;public void inputFile(String fileName) throws Exception &#123; try &#123; in = new BufferedReader(new FileReader(fileName)); try &#123; String s; while ((s = in.readLine()) != null) &#123; //do something &#125; &#125; catch (Exception e) &#123; &#125; finally &#123; //只有成功打开的文件才需要关闭 in.close(); &#125; &#125; catch (FileNotFoundException e) &#123; //此时只要处理找不到文件异常即可 throw e; &#125;&#125; 引申 若一段代码前有异常抛出，并且这个异常没有被捕获，这段代码将产生编译时错误「无法访问的语句」。 若一段代码前有异常抛出，并且这个异常被try...catch所捕获，若此时catch语句中没有抛出新的异常，则这段代码能够被执行，否则，同第上一条。 若在一个条件语句中抛出异常，则程序能被编译，但后面的语句不会被执行。 关于finally finally中的代码总是会被执行，除非在执行try或者catch语句时虚拟机退出（System.exit(1))。 finally块可以做一些资源清理工作，如关闭文件、关闭游标等操作。 finally块不是必须的。 如果在try和finally块中都执行了return语句，最终返回的将是finally中的return值。 异常处理的一般原则 在知道该如何处理的情况下尽早捕获异常。否则继续向上抛出或者转译为RuntimeException——避免抛出过多的异常，影响程序可读性。 自定义非检查型异常（RuntimeException），用以封装所有的检查型异常——让程序决定是否对异常进行处理，防止吞食则有害问题的发生。 只针对异常的情况才使用异常。不要滥用try-catch，因为会影响性能。 为应用系统定义一套属于自己的异常处理框架。这样当异常发生时，才能将异常信息以统一的风格、优雅的反馈给用户。 异常的转译 如果方法抛出的异常与它执行的任务没有明显的联系，这种情形会使人不知所措。为了避免这个问题，更高层的实现应该捕获低层的异常，同时抛出可以按照高层抽象进行解释的异常，这种做法被称为异常转译（exception translation），如下： 12345try&#123; // use lower-level abstraction to do our bidding&#125; catch(LowerLevelException ex)&#123; throw new HigherLevelException(...);&#125; 异常转译的哲学 异常转译是针对所有继承Throwable超类的类而言的，从语法角度讲，其子类之间都可以相互转换。 但是从设计的角度出发，对于异常转译，我们要有一个合理的转译规则，否则各种异常互相转译必然导致代码混乱不堪。笔者认为，一个合理的三大类异常（Error, RuntimeException, 非RuntimeException）的转译关系如下图： 异常转译 将Error和检查型异常（非RuntimeException）转译成RuntimeException是为了增加代码的可读性、挽回因错误（Error）发生带来的负面影响，使代码更为简洁，且有利于异常的统一处理。 异常链 异常的转译涉及到了异常链的概念。在捕获一个异常后，抛出另一个异常，把底层的异常信息传给上层，并且保留底层的异常信息，这就是异常链。JDK1.4以后，Throwable子类在构造器中可以接受一个cause对象(Throwable对象)作为参数，表示原始异常，通过cause参数把原始异常传递给新的上层异常。这样，位于高层的异常递归调用getCause()方法，就可以遍历各层的异常信息。 设计自己的异常处理框架 对于一个应用系统来说，发生的所有异常在用户看来都是应用系统内部的异常。因此，系统内部的异常应该统一的转译成AppAbstractException（或是其他你喜欢的名字），AppAbstractException异常应该能够提供给客户端友好的异常信息。 自定义的异常都应该是RuntimeException（非检查异常）类的子类，以便由开发人员在合适的位置统一处理异常。 应用异常处理框架 eg：Spring中的所有异常都可以用 org.springframework.core.NestedRuntimeException 来表示，并且该基类继承的是RuntimeException。]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>Java Core</category>
      </categories>
      <tags>
        <tag>Java异常</tag>
        <tag>Exception</tag>
        <tag>Java异常体系</tag>
        <tag>异常框架设计</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LaTeX学习]]></title>
    <url>%2Fposts%2F16707.html</url>
    <content type="text"><![CDATA[LaTeX学习 如果你平时的写作中会遇到数学公式，而你又是使用的markdown编辑器，那么，本文适合你。 本文主要介绍LaTex数学排版在MarkDown语法中的使用。如果您需要的是更详尽的LaTeX论文排版等，请查阅相关专业资料。 TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。TEX的版本号不断趋近于π，现在为3.141592。由Pascal 语言写成，特点: 免费、输出质量高、擅长科技排版、有点像编程。 LATEX 目前使用最广泛的TEX 宏集。 每一个LATEX 命令实际上最后都会被转换解释成几个甚至上百个TEX命令。 CTEX 国内致力于TEX 推广的网站：www.ctex.org/。该网站提供了CTEX 中文套装，这个安装程序把MiKTEX（TEX 在Windows 操作系统上的实现版本）和一些相关工具（如WinEdt、GSview 等）打包在一起，同时对中文接口进行了配置，以实现对中文文本的编辑。 如果想学习LATEX安装CTEX套装就可以了。LATEX 的功能和宏包有很多，每个人用到的功能是有限的；边用边学，建立了基本的概念以后，在使用中根据需求去解决问题就可以了。 LaTeX公式基础知识 LATEX控制序列的概念（类似于函数） 控制序列可以是作为命令：以\开头，参数：必须参数{}和可选参数[]。 环境概念 以bengin {环境名}开始，并以end {环境名}结束。 LaTeX 公式有两种，一种是用在正文中的，一种是单独显示的。正文中的公式用 $...$ 来定义，单独显示的用$$...$$ 来定义，其中 ... 表示的是LaTeX 的公式命令。 行内公式： $f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t$.(行内公式) \(f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t\) ​ 行间公式： $$f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t{6}\tag{1}$$ \[f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t{6}\tag{1}\] 上标与下标 上标命令是 ^{角标}，下标命令是_{角标}。当角标是单个字符时可以不用花括号 分式 输入较短的分式时，最简单的方法是使用斜线，譬如输入(x+y)/2，可得到：\((x + y)/2\) 要输入带有水平分数线的公式，可用命令：\frac{分子}{分母}。 eg. $$\frac{x+y}{2}$$ \[\frac{x+y}{2}\] $$\frac{1}{1+\frac{1}{2}}$$ \[\frac{1}{1+\frac{1}{2}}\] 根式 排版根式的命令是：开平方：\sqrt{表达式}；开 n 次方：\sqrt[n]{表达式} $$\sqrt{2}&lt;\sqrt[3]{3}$$ \[\sqrt{2}&lt;\sqrt[3]{3}\] $$\sqrt{1+\sqrt[p]{1+a^2}}$$ \[\sqrt{1+\sqrt[p]{1+a^2}}\] $$\sqrt{1+\sqrt[^p\!]{1+a^2}}$$ \[\sqrt{1+\sqrt[^p\!]{1+a^2}}\] 求和与积分 排版求和符号与积分符号的命令分别为 \sum和 \int，它们通常都有上下限，在排版上就是上标和下标。 $$\sum_{k=1}^{n}\frac{1}{k}$$ \[\sum_{k=1}^{n}\frac{1}{k}\] 微分符直体：$$\int_a^b f(x)\mathrm{d}x$$ \[\int_a^b f(x)\mathrm{d}x\] 公式中的空格 LaTeX 能够自动处理公式中的大多数字符之间的空格，但是有时候需要自己手动进行控制。 命令 释义 显示 $a\!b$ 紧贴 \(a\!b\) $ab$ 没有空格 \(ab\) $a\,b$ 小空格 \(a\,b\) $a\;b$ 中等空格 \(a\;b\) $ab$ 大空格 \(a\ b\) $a\quad b$ quad空格 \(a\quad b\) $a\qquad b$ 两个quad空格 \(a\qquad b\) 西文字符转换表 命令 释义 命令 释义 rm 罗马字体 \it 意大利字体 \bf 黑体 \sl 倾斜体 \sf 等线体 \sc 小体大写字母 \tt 打字机字体 \mit 数学斜体 \cal 数学中花体字母 公式中的定界符 这里所谓的定界符是指包围或分割公式的一些符号 $($ %( $)$ %) $[$ %[ $]$ %] $\{$ %{ $\}$ %} $|$ %| $\|$ %|| 在上述这些定界符之前冠以 \left（修饰左定界符）或 \right（修饰右定界符），可以得到自适应缩放的定界符，它们会根据定界符所包围的公式大小自适应缩放。 $$\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)$$ \[\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)\] 矩阵 对于少于 10 列的矩阵，可使用matrix，pmatrix，bmatrix，Bmatrix，vmatrix 和Vmatrix 等环境。 $$\begin{matrix}1 &amp; 2\\3 &amp;4\end{matrix}$$ \[\begin{matrix}1 &amp; 2\\3 &amp;4\end{matrix}\] $$\begin{pmatrix}1 &amp; 2\\3 &amp;4\end{pmatrix}$$ \[\begin{pmatrix}1 &amp; 2\\3 &amp;4\end{pmatrix}\] $$\begin{bmatrix}1 &amp; 2\\3 &amp;4\end{bmatrix}$$ \[\begin{bmatrix}1 &amp; 2\\3 &amp;4\end{bmatrix}\] $$\begin{Bmatrix}1 &amp; 2\\3 &amp;4\end{Bmatrix}$$ \[\begin{Bmatrix}1 &amp; 2\\3 &amp;4\end{Bmatrix}\] $$\begin{vmatrix}1 &amp; 2\\3 &amp;4\end{vmatrix}$$ \[\begin{vmatrix}1 &amp; 2\\3 &amp;4\end{vmatrix}\] $$\begin{Vmatrix}1 &amp; 2\\3 &amp;4\end{Vmatrix}$$ \[\begin{Vmatrix}1 &amp; 2\\3 &amp;4\end{Vmatrix}\] 排版数组 当矩阵规模超过 10 列，或者上述矩阵类型不敷需求，可使用 array 环境。该环境可把一些元素排列成横竖都对齐的矩形阵列。 12345678$$\mathbf&#123;X&#125; =\left( \begin&#123;array&#125;&#123;ccc&#125;x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \ldots \\x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \ldots \\\vdots &amp; \vdots &amp; \ddots\end&#123;array&#125; \right)$$ \[ \mathbf{X} = \left( \begin{array}{ccc} x_{11} &amp; x_{12} &amp; \ldots \\ x_{21} &amp; x_{22} &amp; \ldots \\ \vdots &amp; \vdots &amp; \ddots \end{array} \right) \] \mathbf大写控制符，\\表示换行，{ccc}表示列样式。array 环境也可以用来排版这样的表达式，表达式中使用一个. 作为其隐藏的\right定界符。 1234567$$y = \left\&#123; \begin&#123;array&#125;&#123;ll&#125;a &amp; \textrm&#123;if $d&gt;c$&#125;\\b+x &amp; \textrm&#123;in the morning&#125;\\l &amp; \textrm&#123;all day long&#125;\end&#123;array&#125; \right.$$ \[ y = \left\{ \begin{array}{ll} a &amp; \textrm{if $d&gt;c$}\\ b+x &amp; \textrm{in the morning}\\ l &amp; \textrm{all day long} \end{array} \right. \] 也可以在array环境中画线，如分隔矩阵中元素。 1234567$$\left(\begin&#123;array&#125;&#123;c|c&#125;1 &amp; 2 \\\hline3 &amp; 4\end&#123;array&#125;\right)$$ \[ \left(\begin{array}{c|c} 1 &amp; 2 \\ \hline 3 &amp; 4 \end{array}\right) \] 基本LaTeX 公式命令 希腊字母 命令 显示 \alpha \(\alpha\) \beta \(\beta\) \gamma \(\gamma\) \delta \(\delta\) \zeta \(\zeta\) \epsilon \(\epsilon\) \eta \(\eta\) \theta \(\theta\) \iota \(\iota\) \kappa \(\kappa\) \lambda \(\lambda\) \mu \(\mu\) \xi \(\xi\) \nu \(\nu\) \pi \(\pi\) \rho \(\rho\) \sigma \(\sigma\) \tau \(\tau\) \upsilon \(\upsilon\) \phi \(\phi\) \chi \(\chi\) \psi \(\psi\) \omega \(\omega\) 如果使用大写的希腊字母，把命令的首字母变成大写即可，例如 \Gamma 输出的是 \(\Gamma\)。 如果使用斜体大写希腊字母，再在大写希腊字母的LaTeX命令前加上var，例如\varGamma 生成 \(\varGamma\)。 eg. 123$$ \varGamma(x) = \frac&#123;\int_&#123;\alpha&#125;^&#123;\beta&#125; g(t)(x-t)^2\text&#123; d&#125;t &#125;&#123;\phi(x)\sum_&#123;i=0&#125;^&#123;N-1&#125; \omega_i&#125; \tag&#123;2&#125;$$ 生成如下结果： \[ \varGamma(x) = \frac{\int_{\alpha}^{\beta} g(t)(x-t)^2\text{ d}t }{\phi(x)\sum_{i=0}^{N-1} \omega_i} \tag{2} \] 和号和积分号 命令 显示 \sum \(\sum\) \int \(\int\) \sum_{i=1}^{N} \(\sum_{i=1}^{N}\) \int_{a}^{b} \(\int_{a}^{b}\) \prod \(\prod\) \iint \(\iint\) \prod_{i=1}^{N} \(\prod_{i=1}^{N}\) \iint_{a}^{b} \(\iint_{a}^{b}\) \bigcup \(\bigcup\) \bigcap \(\bigcap\) \bigcup_{i=1}^{N} \(\bigcup_{i=1}^{N}\) \bigcap_{i=1}^{N} \(\bigcap_{i=1}^{N}\) 其它常用命令 命令 显示 \sqrt[3]{2} \(\sqrt[3]{2}\) \sqrt{2} \(\sqrt{2}\) x^{3} \(x^{3}\) x_{3} \(x_{3}\) \lim_{x \to 0} \(\lim_{x \to 0}\) \frac{1}{2} \(\frac{1}{2}\) 注意：上标和下标在只有一个字符时，可以不用中括号: x^2和x^{2}的结果都是 \(x^2\) 数学符号的修饰 命令 释义 显示 \overline{数学公式} 上划线 \(\overline{数学公式}\) \underline{数学公式} 下划线 \(\underline{数学公式}\) \overbrace{数学表达式} 俯卧式花括号 \(\overbrace{数学表达式}\) \underbrace{数学表达式} 仰卧式花括号 \(\underbrace{数学表达式}\) LaTeX学术写作 目前markdown语法对于LaTeX的支持比较有限，主要是公式语法，对于论文写作的语法支持很少。 \(\title[LaTeX公式语法]{markdown中对于LaTeX语法的支持}\) \(\subtitle{subtitle here}\) \(\author[Laphi\;Lee]{Laphi Lee}\)]]></content>
      <categories>
        <category>技术</category>
        <category>other</category>
        <category>LaTeX</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
        <tag>LaTeX学习</tag>
        <tag>LaTeX markdown</tag>
        <tag>Latex md</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git拾遗]]></title>
    <url>%2Fposts%2F19482.html</url>
    <content type="text"><![CDATA[整理一些git中非常有用且自己又容易忘记的命令，仅供参考。 github上fork代码后，从自己的代码库拉下代码。如何保持自己库中的代码和原代码的更新保持一致呢？ *步骤：在 Fork 的代码库中添加上游代码库的 remote 源，该操作只需操作一次即可。 在 Fork 的代码库中添加上游代码库的 remote 源，该操作只需操作一次即可。 如: 其中 upstream 表示上游代码库名， 可以任意。 git remote add {upstream} git@github.com:spring-projects/spring-framework.git 将本地的修改提交 commit 在每次 Pull Request 前做如下操作，即可实现和上游版本库的同步。 ​ 3.1 ： git remote update upstream ​ 3.2 ： git rebase upstream/{branch name} 需要注意的是在操作3.2之前，一定要将checkout到{branch name}所指定的branch， 如: git checkout develop push 代码到 github ​ git push origin {branch name} git在本地新建分支并与远程库建立关联的几种方法 git checkout --track origin/remote_branch（推荐） 基于远程分支“remote_branch”，创建一个叫“remote_branch”的本地分支。 git checkout -b remote_branch origin/remote_branch git clone -b {remote_branch} git@github.com:spring-projects/spring-framework.git git branch remote_branch , git checkout remote_branch, git pull origin remote_branch git branch --set-upstream-to=origin/&lt;branch&gt; {remote_branch} git设置提交代码时显示的提交人信息 git config —global user.name laphi git config —global user.email laphi@laphilee.com 生成git帐号关联邮箱的rsa：git ssh-keygen -t rsa -C laphi@laphilee.com。 这里不强制要求用git生成rsa，直接用不和邮箱信息关联的rsa也完全可以。 git删除远程分支 如果一不小心把本地的临时分支push到server上去了，想要删除。怎么办？ 用git branch -r -d origin/branch-name只是删除的本地对该远程分支的track，不能删除远程服务器（如github，gitlab等）上的该分支。正确的方法应该是这样：git push origin :branch-name冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支。 或者用命令git push origin --delete &lt;branchName&gt; 删除不存在对应远程分支的本地分支 假设这样一种情况： 我创建了本地分支b1并pull到远程分支 origin/b1； 其他人在本地使用fetch或pull创建了本地的b1分支； 我删除了 origin/b1 远程分支； 其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？ 使用下面的代码查看b1的状态： 123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use &apos;git remote prune&apos; to remove) Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。 更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支： git fetch -p 重命名远程分支 在Git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 123xiaosi@Q:~/code/qt$ git branch -av* dev 8d807de MOD master f600e50 code change during build remotes/origin/HEAD -&gt; origin/master remotes/origin/dev 8d807de MOD remotes/origin/master f600e50 code change during build 删除远程分支：git push --delete origin dev 重命名本地分支：git branch -m dev develop 推送本地分支：git push origin develop 设置git区分文件名大小写 git 默认是不区分文件名大小写的，当我们不小心把文件名的大小写写错了，想改过来，会发现push不起作用。 譬如当你创建一个文件后，叫 readme.md 写入内容后 提交到线上代码仓库。然后你在本地修改文件名为Readme.md 接着你去提交，发现代码没有变化.git status无任何提示信息。 这里有两种解决方法 配置git使其对文件名大小写敏感：git config core.ignorecase false 在本地仓库把文件删除，提交，然后push到远程仓库，然后再在本地重新添加正确文件名的文件，然后再push。 删除 1git rm readme.md push到远程仓库 12git commit -m 'readme.md'git push origin &lt;my_branch&gt; 重新添加 1git add Readme.md 提交 12git commit -m 'Readme.md'git push origin &lt;my_branch&gt; 这里推荐使用第一种方法，一劳永逸。 rebase 使用rebase和其他分支直接合并（不推荐，会有很多冲突） 假设你现在基于远程分支“origin”，创建一个叫“mywork”的分支。 1$ git checkout -b mywork origin img 现在我们在这个分支做一些修改，然后生成两个提交(commit). 12345$ vi file.txt$ git commit$ vi otherfile.txt$ git commit... 但是与此同时，有些人也在“origin”分支上做了一些修改并且做了提交了. 这就意味着“origin”和“mywork”这两个分支各自“前进”了，它们之间“分叉”了。 img 在这里，你可以用“pull”命令把“origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的“合并的提交”(merge commit): img 但是，如果你想让“mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 git rebase: 12$ git checkout mywork$ git rebase origin 这些命令会把你的“mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到“.git/rebase”目录中),然后把“mywork”分支更新到最新的“origin”分支，最后把保存的这些补丁应用到“mywork”分支上。 img 当’mywork’分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. （请查看 git gc) img 现在我们可以看一下用合并(merge)和用rebase所产生的历史的区别： img 在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用git-add命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行: 1$ git rebase --continue 这样git会继续应用(apply)余下的补丁。 在任何时候，你可以用--abort参数来终止rebase的行动，并且“mywork” 分支会回到rebase开始前的状态。 1$ git rebase --abort 使用rebase来合并当前分支commit，然后再和其他分支merge（推荐） git rebase -i HEAD~8 合并最近的8次commit。 git rebase -i i870cs “i870cs” 为不参与合并的最后一个commit 注：commit排序为倒序。即最新的commit在最上面。 从第二行开始，将pick改为s(s, squash = use commit, but meld into previous commit ) wq保存并退出。 如果有冲突，修改冲突后 12git add . git rebase --continue 如果想放弃rebase，执行git rebase --abort 将rebase同步到远程：git push origin &lt;your-branch&gt; 标签（tag） 当代码写到一个里程碑版本的时候，为了方便日后查看版本以及代码回滚，这时候需要打tag 创建标签： git tag v1.4-lw。此为轻量级标签，无需任何参数。 （推荐使用带附注的标签）git tag -a v20170725 -m &quot;打标签&quot;。此处的-a表示含附注类型的标签，而 -m 选项则指定了对应的标签说明。 或者根据指定的commit打tag：git tag -a v20170725 -m &quot;打标签&quot; dd98asd 将标签同步到远程(和操作普通分支没有区别)：git push origin v20170725 查看所有标签列表：git tag，或者如果你只对某些特定的标签感兴趣，可以用git tag -l 'v1.4.2.*' 可以用git show &lt;tagname&gt;查看标签信息： 12345tag v20170725Tagger: laphi &lt;laphi@laphilee.com&gt;Date: Tue Jul 25 09:39:27 2017 +0800我的tag 移除gitignore中已经被忽略的文件或目录 问题： 在初始化git仓库的时候没有创建.gitignore文件来过滤不必要提交的文件, 后来却发现某些文件不需要提交, 但是这些文件已经被提交了, 这时候创建.gitignore文件忽略这些文件时, 发现ignore的规则对那些已经被track的文件无效. 其实.gitignore文件只会忽略那些没有被跟踪的文件, 也就是说ignore规则只对那些在规则建立之后被新创建的新文件生效. 因此推荐: 初始化git项目时就创建.gitignore文件. 但是如果是一个老的项目里面新添加的.gitignore，很有可能会出现上面我们提到的问题。如何把git提示“ignored tracked with git”的文件忽略掉呢？可使用如下命令： 命令：git rm --cached -r 文件／文件夹 eg. git rm --cached -r ../biz/myproject.iml 选择性合并 场景: 某天你正在做一个新的需求，突然有一天产品告诉你说有一个新特性需要提前上线，那么怎么办呢？ 该cherry-pick上场了，cherry-pick会重演某些commit，即把某些commit的更改重新执行一遍。 git cherry-pick commit 注：这里的commit可以是同分支的commit，也可以是不同分支的。 Git 命令别名 如果觉得git命令太长，每次重复输入太麻烦，可以使用git别名，用你自己容易记住和使用的别名来为自己节省时间。 git config --global alias.co checkout git config --global alias.br branch git config --global alias.ci commit git config --global alias.st status]]></content>
      <categories>
        <category>技术</category>
        <category>other</category>
        <category>git</category>
      </categories>
      <tags>
        <tag>git</tag>
        <tag>git拾遗</tag>
        <tag>常用git命令</tag>
        <tag>git学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[漫谈钓鱼]]></title>
    <url>%2Fposts%2F36312.html</url>
    <content type="text"><![CDATA[转载一个老钓鱼人的总结 说到钓鱼，就一定要谈论技巧，据我了解有四点最重要。即“善观气候、选准钓位、钓组合理、饵料对路”，分述如下。 一、善观气候 俗语说：“打鱼不问风浪事，焉能打得大鱼回。”垂钓也不例外，寒暑阴阳，风雨水流都直接影响钓鱼效果。 在一年中，“清明”和“霜降”两个节气冷暖适中好钓鱼。但绝非仅有这两个节气能钓到鱼，不同的季节采取不同的方法并对准不同时段亦可开竿取得好钓绩。从总体上看： 春钓一天，夏钓早晚，秋钓黄昏，冬钓午间； 钓阴不钓阳，钓暗不钓明，鱼类对光线比较敏感，它们为避开天敌形成喜阴怕阳和爱清静的习性，为此必须注意阴阳、明暗的变化。 这里说的阴阳、明暗有双重含义：一是阴天比晴天好钓；二是除冬天外，夜间比白天好钓，但有些鱼如鲢鳙、草鱼、鱤鱼则靠白天钓获，夜间则与之相反。盛春初夏，繁花似锦，百业俱兴，亦是钓鱼的大好时光，但在这一时段气候尤为多变，出门垂钓更要善观气候变化。 六个气候变化要注意 “房潮有雾切莫赶路”整天远山和高大建筑物群笼罩在浓雾之中，能见度低，同时居家平房板石地面及水泥地或高楼底层地面潮湿，墙壁”冒汗”，布满水珠的反潮天气，气压低不宜出门垂钓。 “雾退见山赶快下竿”在连续数天山边及高大建筑物云雾连天，突然天高气爽，又是阴天或多云天气，此时出门垂钓必有重大收获，故有“远山看得清，钓鱼无暇吃点心”的传云。 “暴冷暴热不出门，天气突变不垂钓”譬如久雨突然放晴或久晴暴雨突袭，这时水温急剧变化，鱼类不适应，垂钓效果必然欠佳。 此外还要注意另外两种现象：一种是“暴风骤雨你莫钓，风雨过后总丰收”。这里着重指的是台风多发季节，刮台风时不但难开竿放钓，且鱼类潜入深水避风，要等风停，水面清静或细雨蒙蒙，十拿九稳喜获丰收；二是“雷雨离钓场，雨中不下竿”。垂钓多在空旷、临山及平原大水面等区域，这些地方往往是雷区，且近年来多数钓友采用碳素钓竿属导电体，雨中易遭雷击极度危险，同时鱼也怕雷，冒雨垂钓也是白忙，以暂离钓位为宜。 “雨中水面冒蒸气，下竿垂钓最有利”尤其初春，细雨蒙蒙，水面热气腾腾，下雨溶氧，水里温度高，增进鱼类食欲是难得的钓鱼好时期，不可错过。 “水中冒泡泡，大鱼小鱼都好钓”这是钓者熟知的道理，鱼冒泡泡，是鱼类寻觅的一种讯号，春末初夏尤为常见，即时好钓鱼。但在这段时间冒沼气亦较为常见，为此要分清鱼泡泡与沼气泡。鱼泡泡：泡粒较小，多在两个或数个以上，如鲫、鳊等;鲤鱼、鲇鱼爱拱泥，呈现成片泡泡有其独特之处；沼气泡一般单个、粒体大。同时冒沼气时，水面较常见有胶状水膜或从水底向水面悬浮块状似如青苔物质，下风口最明显，这种自然现象是由水变质冒沼气，水中必缺氧，鱼类懒于觅食，要善断，把沼气泡误为鱼泡泡垂钓必空忙。 “鱼儿水面跳，远近都好钓”鱼儿水面跳春夏较为常见，无论池塘、湖泊、库区鱼儿水面戏耍跳跃，觅食积极，近钓远钓两相宜，必获好钓绩。但亦要严格识别“鱼浮头”的现象，“鱼儿水面张口，垂钓必空手”，鱼儿水面张口是由水中缺氧所致，一般先是鲢鱼、草鱼、鳊鱼，特别鲫鱼、罗非鱼、鳙鱼成群在水面张口，水中缺氧尤为厉害，这时鱼类自命不保，怎想觅食，除非钩鱼，垂钓定无所获。另有一种情况，清晨碰到河虾在水面浮游及成群堆集岸边及杂草边，亦是鱼难钓的时段，要等河虾沉入水中方可开竿，但当天往往鱼咬钩不太积极。 刮什么风也会直接影响 除上述六点外，如下几种情况也不容忽视。首先是风向，刮什么风也会直接影响 “东南风钓鱼好轻松，风起西南收竿回转” “宁钓北风寒，不钓南风暖” “微风好钓鱼，无风鱼难钓” “风大钓上层，无风靠底钓” 这些都要引起垂钓者注意的问题。 温度更是直接的影响 其次温度更是直接影响钓鱼效果。水面温度低于摄氏13度，只有到深水区域及避风的地方垂钓。温度高于摄氏35度，除了钓鲢鳙鱼、鲮鱼、草鱼例外，多数鱼类则游弋深塘，大面积水域却难以找到它们的踪影。再次温差也极为关键。“温差六和五，钓鱼好辛苦”。 一年四季温差在摄氏五度和六度之间（即曰平均温度最高温度与最低温度之间的温度为温差），水中多为缺氧天气不宜垂钓。“温差七、八、九，钓鱼归来送朋友”，温差在七、八、九度出钓必获丰收，自己吃不完只好奉送朋友，分享丰收喜悦。别看与六度只有一度之差，钓鱼效果就是不一样，见怪则不怪。对于温差也并非愈小愈好，温差小一般在寒冬与雨季，适合钓白鲫鱼、白鲦、翘嘴鱼白、鳊鲤等;温差大于10度以上，多在炎热的夏秋较为常见。 夏秋季节，“低温25℃，高温33℃，出门垂钓不空竿”，是难得钓鱼好时光。但低温上升到摄氏26度，高温升到摄氏36度以上白天鱼难钓，只有黄昏及夜钓最见成效。 天气是我们出钓制胜的法宝，象10月下旬的绵绵中小雨让很多垂钓爱好者失去垂钓的信心，也许这样的天气正是鱼欢虾乐的垂钓好时光。而11月初阳光明媚的晴好天气又激起了我们外出垂钓的欲望，虽然天气晴好但出钓的效果也许差强人意。什么样的天气鱼儿才会开心呢？什么样的天气才会带给我们垂钓之乐呢？决定垂钓天气的好坏有五大因素：温度，温差，湿度，气压，风。 温度：水温越低水中溶氧越丰富，当水温高于30度以上时水体趋于溶氧不足，水温越高水体与空气的对流越差。所以我们夏天至初秋总是觉得钓鱼找不到感觉，有时人感觉天气很凉爽但出钓效果差强人意（是由于水温没降水中缺氧）。当进入深秋后气温趋于向冷，日温差也慢慢变小，天气逐渐稳定，只要我们有时间出钓定会让我们有所收获。冬季垂钓鲫鱼往往比夏天强很多，而且个大体肥。冬季垂钓没有太阳的炽热，没有雷电暴雨大风的干扰，水温稳定溶氧丰富对垂钓利。 温差对钓鱼的影响 温差：这里主要指日温差（一日中最高温度与最低温度之差），若日温差超过10度以上鱼儿就会消耗很大一部分能量变温来达到适应环境，顺应自然，这时鱼儿觅食欲望低下还无食欲。当日温差在7度左右时鱼儿能正常觅食，对垂钓有利。 湿度和钓鱼的关系 湿度：当空气中湿度达到100%时，空气中弥漫着大量水蒸气，水与空气的对流交换受阻，水中溶氧不足，使水体缺氧，鱼儿要消耗体力来与之抗衡，这时鱼儿觅食欲望低下还无食欲。若空气湿度在70%以上时对垂钓影响较大，只有当空气湿度小于50%才会对垂钓有利。 气压对钓鱼的影响 气压：通常指1个标准大气压值为正常气压，若低于标准大气压值为低气压天气，当低气压天气出现时由于水体内部压力相对变大空气中的氧气不能正常的溶入水体进行对流（当低气压天气严重时水底污泥中的有毒气体溢出与水体混合使水质发生改变鱼儿浮头还死亡），水中缺氧，鱼儿迫切需要的是氧而不是食物，对垂钓非常不利。只有在标准大气压值正常还趋高的天气情况下水中溶氧正常还充足，鱼儿寻觅食物的欲望强烈，对垂钓有利。 风力对钓鱼影响 风：当风达到5级以上时对垂钓不利，细雨微风对垂钓有利（冬季里的雪雨寒风另当别论），由于雨水会给水体带来空气中丰富的氧气，而微风又起着捣拌机的功效使水体溶氧充足，鱼儿觅食积极。还有就是风向，风无论向什么方向吹只要一日内风向不变，水体水域中的溶氧稳定鱼就好钓，若一天中风向不停的改变着，水与空气的对流也变化着（风能吹到的地方溶氧就充足反知次之），在垂钓中反应出来就是鱼情时好时坏，若一天中风向不停的改变着，遇到这种天气对垂钓也很不利。 当我们了解了鱼与天气的的关系后，接下来我们只要了解各类型鱼在什么水域栖息，喜欢吃什么饵，做到心中有数垂钓起来就容易了。 天气变化对江，河，溪流影响较大。湖泊，大型水库次之。水面越小受天气影响越大。在垂钓中当我们遇到不利天气时我们可以选择流动的水域和大型的湖泊，水库，这样就可以机动灵活做到知已知比，方能出奇制胜。 这是我在平时垂钓中的感受和体会，还有很多地方不全面，望各位钓友一起商榷和探讨。 二、选准钓位 野钓鲫鱼的选位 其实钓鱼人都知道鲫鱼是除了白条之外最好钓的鱼。虽然其好钓的原因很多但主要有三点： 鲫鱼生长繁殖力强，适应水域广，遍布我国各地无污染的淡水水域，数量上较其它淡水鱼有很大优势。 其个体较小在提竿。溜鱼等技巧上要求不高。不需要很高的钓技。 鲫鱼属杂食性，且比较贪食，因此诱饵和钓饵的配制都不很复杂，只要掌握了关键的几点就不愁钓不到鱼。 之所以要谈鲫鱼的钓法并不是本人对鲫鱼有特殊的兴趣，只是因为本人虽然以有30多年的钓龄而网龄却不长。看到网上有很多初学钓鱼的人对鲫鱼感兴趣，因此想谈一谈自己多年来钓野鲫鱼的体会以供参考。 钓鲫鱼的选位和钓其它鱼是不同的。钓鲫鱼选位要选草边，岸边，选旮旮旯旯的地方。比如说在湖泊、水库等大水面钓鲫鱼要找和大水面相连的沟沟岔岔等局部小水面。如果没有沟岔就要选靠近岸边的凹处离岸不要太远，最好选在草边或者是与大水面相通的草洞，只要有适当的水深越是靠近草或岸越好，水深根据季节不同可选择0.5—3米之间（最多不超过5米）但选择岸边时，必须选择凹处，谚语云：“鲤鱼钓凸，鲫鱼钓凹”。冬天和初春可选在北岸或东岸，且离岸可稍远一点的深水。晚春就要选择潜水处。有些场合水深甚至只有0.3米只要水混也会有意想不到的钓获量（潜水钓可用4粒星漂，多了没用，以饵代坠或者用很小的铅坠。）秋季要选择南岸或西岸的背阴处只要有1—3米的水深就行，最好是找到水底深浅交界处的深水处或者斜坡的靠近坡底处效果会非常好。 就是钓草边季节不同，下钩点也不同，比如：春季应该钓草丛的南边，秋季就要钓草丛的北边，哪怕是只有一两棵草，根据季节不同选择草的向阳一侧或背阴一侧效果也会截然不同。在野钓过程中选择钓位和下钩点（钓点）非常重要，有时在同一个钓位，下钩点相差不足0.5米钓效却差距很大。特别是在水面不很大的水草溏里更是如此。 盛夏不是钓鱼的好季节，但不是不能钓，只是盛夏钓鱼无论是选位还是钓法上都要比春秋季节钓鱼更要复杂些，比如谚语中说的“早钓东，晚钓西”一般只在夏天才用的上。我说个夏季钓鱼的小门道大家不妨一试。定点打窝后，下钩时不要把钩下在窝子中间，比如你如果准备钓草边离草一尺远的地方，那么你大窝时要把窝打在离草1米远，下钩时把钩下在窝和草中间离草一尺远的地方会非常好。如果是钓岸边，要把钩下在窝的前方二尺左右的地方，其效果会比把钩下在窝子中好的多。 谚语中说的“春钓滩，夏钓潭，秋钓荫，冬钓阳。”虽然说的很好，但在实际应用中却有很多非常实际的细节问题需要注意。 我国地域辽阔960万平方公里虽然都是同一天立春，但各地的温度却差距很大。而且从立春到立夏有两个多月的时间。要说在这两个多月的时间内全国各地钓鱼都要钓滩显然是荒唐之说。所以“春钓滩”只是个广义的说法，要求更确切些就必须根据实际温度来决定。之所以要“春钓滩”的原因很多但起决定因素的只有两点： 到了春季温度回升浅滩比深水处水温升高的要早，浅滩处的水温高于深水处的水温。 水中的各种生物经过了漫长的冬天到了水温回升的季节那里水温高就到那里去，所以鱼到水温较高的浅滩不仅可以找到更适宜自身温度的生存环境，还可以在那里找到其它浮游生物来填饱饿了一冬的辘辘饥肠。 虽然鱼有三趋（趋温。趋氧。趋食），但在不同的季节却有主次之分：冬春季节主要趋温，要以温度为主要依据考虑选择钓位。盛夏主要趋氧，在炎热的夏天要以水中溶氧量的高低作为选择钓位的主要依据，比如选草边； 选下风口。而到了秋季鱼为了储存足够的越冬脂肪要大量进食，因此主要趋食，那里食物丰富就到那里去。比如回风湾（水面上积存漂浮物多的地方）。大树下。选择岸边的大树下要看当天的风向，如果是南风就要选择南岸的树下（以次类推），若是两到三天风向不变效果更佳。“夏钓潭”也不是绝对的。比如阴雨天气或者有风的天气选择有长出水面的草旁或回风湾效果会更好。 钓鱼的选位非常重要，但也是钓鱼技术中最难掌握的一个环节，要选好一个钓位——特别是选准一个好钓点（下钩点），要根据季节、天气、风向、地形、水情、鱼情、垂钓者的多少等方方面面的因素来考虑，不可死板硬套。要在长期的垂钓活动中多留心，多总结积累经验。切不可每到一处就急忙打窝，要在选择一处钓位之后先安好竿线试探水下地形，选准了下钩点之后再决定打窝点,做到有的放矢。 顺便再说几句根据天气选位 春季要尽量选择下风口的滩，只要不超过4级。因为下风口的水温相对较高。 夏季只要风力不超过4级也要尽量选择下风口，风力越大钓点要离岸越近，因为下风口水的溶氧量高。 秋季既要选择背阴处又要考虑选择下风口或者回风湾，因为那里的食物较多。 冬季则要选择背风处，因为下风口的水温会更低。 出钓前一天听天气预报时不仅要听阴晴风雨，还要注意昼夜最大温差和气压，如果出钓当天的温差大于13度或者气压低于1004佰帕，鱼就会非常难钓，钓草边或草洞会略好些，如果用的是台钓采取漂接钓法钓半水或钓浮会好一点。下风口或者回风湾会更好。回风湾效果会更好。 三、钓组合理 以重量计费的鱼池一般我是不去的，不是野钓就是钓只管不喂的低价鱼塘。这样，所遇环境往往对象鱼密度小，常常有小杂鱼。为了适应，我专门设计了一种钓组和相应的钓法。我已沿用了八年，感觉很好。 钓组 取绿色软渔线一段，用绿色是因为鱼对这种颜色不敏感，一端系一只钓钩，两钩间脑线长约30厘米。用手指从中间挑起，两钩脑线一长一短，相距5厘米左右，在手指下端部位打一个结，留出手指粗的套，用来连接主线。剪一条一厘米宽的铅皮，铅皮的重量相当于4-5目漂梢的排水量，也就是放上铅皮漂头在水面剩一目，拿下就上来4-5目。 每个钩的脑线上卷一块，长脑线上的铅皮移至短脑线钓钩的钩弯处，将铅皮卷一厘米长的中间对准钩弯顶部，用钳子夹紧。另外一个脑线上的铅皮卷在距钩柄3厘米处夹紧。然后，在套结与铅皮间的脑线上刷上101胶，作用是防止在垂钓时两脑线相互缠绕。其它结构和别的钓友没有什么区别。 调漂和使用 漂我采用浮力大且目段较粗的，一般漂目直径在1.5毫米左右，夜钓时就用3毫米的。一个原因是我已花甲之年，细了看不清;主要原因是可以达到我想要的效果。调漂时，空钩不落底，漂只露一点点尖，垂钓时只露一目。甩线时，尽量往前抛，落水后漂一立起来就往后拖竿，超过正常放竿位置十多厘米。当漂不动后，把竿推到正常放竿位置。 这时水下前钩卧底，脑线上的小坠斜立，短脑线钩直立水底。这样前钩没有鱼咬钩漂无信号，后钩当鱼儿觅食时的虚假动作反映到漂上就是点动，小杂鱼逗钩也是如此。因此，鲫鱼咬钩时，只出现黑漂或者送漂两种信号，很容易看清，提高了上钩率。 饵料对路 有句俗语：“甩到水缸里，神仙也无戏。”意思是野钓选位是最重要的，我认为野钓中第二位的就是诱饵。我的诱饵的主要成份：三分之一小米，三分之一玉米面，三分之一麦麸。制做方法：每公斤加50克羊油和70克精盐炒熟，装好备用;使用时，在前一天晚上加适量的糖、泡制的桂皮曲酒，最后用曲酒将所有饵料浸透，这样诱饵就制成了。 这种诱饵的特点是味浓，入水后饵雾存留时间长。有人会问为什么用盐，我过去的主要业余生活是冬猎夏钓，发现一些人为了让鹿按一定规律活动，使用撒盐的办法来引导。我想山里的鹿从未见过盐，怎么会被盐吸引？鱼会不会也对盐感兴趣？当试用后我发现鱼也喜欢盐。 钓友们说我最抠，我比谁用得诱饵都少。我的投饵器是老式的，用乒乓球和自行车内胎做的。第一次投饵多一些，以后每次只是刚刚盖住乒乓球。频率根据鱼情而定，一般不超过半小时就喂一次。投饵要集中，落饵点半径不超过10厘米，我一天最多用诱饵不超过300克。我的用意是，鱼寻味而来，到窝后最醒目，最吸引鱼的是钓饵。 我用钓饵也少，有时用蚯蚓，由于好闹小鱼，一般都是面食搓饵。大的像黄豆粒，小的像高粱米粒。搓饵的硬度和压面条的面一样，甚至还要硬，挂饵时手指要感觉到钓尖。目的： 减少挂饵的次数 抵挡小鱼逗钩 上鱼准确率高 原料：过去用细玉米面加糖，用开水烫过蒸熟，现在是商品饵。我的体会是：在野钓中，野生鱼一般对饵不太挑剔，两种饵的差别不大。不过，商品饵更理想，更方便。]]></content>
      <categories>
        <category>生活</category>
        <category>渔乐</category>
        <category>钓鱼技巧</category>
      </categories>
      <tags>
        <tag>钓鱼</tag>
        <tag>钓鱼与天气</tag>
        <tag>钓鱼技巧</tag>
        <tag>钓位</tag>
        <tag>调漂</tag>
        <tag>饵料</tag>
        <tag>野钓</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Integer剖析]]></title>
    <url>%2Fposts%2F46138.html</url>
    <content type="text"><![CDATA[Java Integer剖析 获取String的整型值的方法 public Integer valueOf(String str) Java获取字符串的十进制Integer整型值 123public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10));&#125; 底层调用的是Integer.parseInt(String s, int radix)，然后通过Integer.valueOf(int i)将parseInt返回的int值封装成Integer对象。 注意：Integer.valueOf(int i)中对需要封装成Integer的int值做了缓存，常用的Integer值，默认[－128～127］可直接通过缓存获取，否则新建Integer。这样也就导致了一个Integer的自动装箱的问题，后面谈到equals和==时我们再来分析。 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)];//IntegerCache数组中存在，直接返回Integer 对象，否则创建新Integer对象 return new Integer(i);&#125; 当然这里的缓存int的最大值是可以设置的，通过java.lang.Integer.IntegerCache.high属性来设置。 1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127);//默认最小的max值是127 // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1);//确保cache数组的大小不超过Integer的最大限度 &#125; high = h; cache = new Integer[(high - low) + 1];//创建缓存数组，给定大小 int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++);//初始化缓存数组 &#125; private IntegerCache() &#123;&#125;&#125; public int parseInt(String str) 解析String的int值，返回int型数值 parseInt(String str) ，底层调用int parseInt(String s, int radix), radix默认10 123public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125; parseInt(String s, int radix)的实现如下。这个方法也是很著名的atoi（字符串转int），面试题里面出现的概率很高——想想如果让自己写代码来实现，能否写的出来？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/***@param s 要转换成int的String字符串。parseInt只接收带‘＋’，‘－’或纯数值(8进制，16进制，10进制)，不自动判断进制数, 需要靠后面的radix来指定———区别于decode(String str)*@param radix String字符串中的数字的进制数*@return 转换后的十进制数*/public static int parseInt(String s, int radix) throws NumberFormatException&#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException("null"); &#125; if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX"); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX"); &#125; int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar &lt; '0') &#123; // Possible leading "+" or "-" if (firstChar == '-') &#123; negative = true; limit = Integer.MIN_VALUE; &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone "+" or "-" throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix);//获取char的int值 if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; result *= radix;//如传入String为“123”，radix为10.计算过程为i = ((-1*10 - 2)*10 - 3)*10 if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; return negative ? result : -result;&#125; parseInt(String s,int radix)就是求int radix进制数String s的radix进制数是多少。 Integer decode(String nm) decode方法可以接收带有’0x’, ‘0X’, ‘#’(16进制)，‘0’(8进制)前缀的字符串，自动判断进制数，底层调用的Integer.valueOf(String str, int radix)——&gt;Integer.parseInt(String str, int radix)。 decode(String str)相对于parseInt(String str, int radix)多了自动判断进制数的功能，且返回值是Integer对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static Integer decode(String nm) throws NumberFormatException &#123; int radix = 10; int index = 0; boolean negative = false; Integer result; if (nm.length() == 0) throw new NumberFormatException("Zero length string"); char firstChar = nm.charAt(0); // Handle sign, if present if (firstChar == '-') &#123; negative = true; index++; &#125; else if (firstChar == '+') index++; // Handle radix specifier, if present if (nm.startsWith("0x", index) || nm.startsWith("0X", index)) &#123; index += 2; radix = 16; &#125; else if (nm.startsWith("#", index)) &#123; index ++; radix = 16; &#125; else if (nm.startsWith("0", index) &amp;&amp; nm.length() &gt; 1 + index) &#123; index ++; radix = 8; &#125; if (nm.startsWith("-", index) || nm.startsWith("+", index)) throw new NumberFormatException("Sign character in wrong position"); try &#123; result = Integer.valueOf(nm.substring(index), radix);//底层调用valueOf(String str, int radix) --&gt; parseInt(String str, int radix) result = negative ? Integer.valueOf(-result.intValue()) : result; &#125; catch (NumberFormatException e) &#123; // If number is Integer.MIN_VALUE, we'll end up here. The next line // handles this case, and causes any genuine format error to be // rethrown. String constant = negative ? ("-" + nm.substring(index)) : nm.substring(index); result = Integer.valueOf(constant, radix); &#125; return result;&#125; Integer.getInteger(String str, Integer val); 此方法用于获取系统属性的Integer值 1234567/*** 如果需要获取系统的属性值的话，推荐使用getInteger(String nm, Integer val)，可以省去一层调用和一个判断*/public static Integer getInteger(String nm, int val) &#123; Integer result = getInteger(nm, null); return (result == null) ? Integer.valueOf(val) : result;&#125; 1234567891011121314151617181920/***@param nm 系统属性的名字，如"java.lang.Integer.IntegerCache.high"*@param val 获取系统属性失败的情况下的默认值*@return 属性对应的Integer值*/public static Integer getInteger(String nm, Integer val) &#123; String v = null; try &#123; v = System.getProperty(nm); &#125; catch (IllegalArgumentException e) &#123; &#125; catch (NullPointerException e) &#123; &#125; if (v != null) &#123; try &#123; return Integer.decode(v);//底层调用的decode，把str解析成对应的十进制Integer &#125; catch (NumberFormatException e) &#123; &#125; &#125; return val;&#125; 总结 Atoi使用推荐 返回值Integer 返回值int str是十进制 valueOf(String str) parseInt(String str) str非十进制 decode(String str)(需解析radix) ｜valueOf(String str, int radix)(不需要解析radix) parseInt(String str, int radix)(str不能带radix标识，但可以带‘＋’、‘－’号) Integer中的其它方法 compareTo(Integer anotherInteger) 比较两个Integer数值的大小 1234567/*** @param 要比较的另一个Integer* @return 相等返回0，小于anotherInteger返回－1，大于anotherInteger返回1*/public int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125; 底层使用的方法 123public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);&#125; Integer中的equals方法 123456public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 关于equals(Object obj)和==，自动装箱的坑 前两天看到一个面试题，大体就是下面这样的代码： 123456789public class Test &#123; public static void main(String[] args) throws Exception &#123; Integer i1 = 10, i2 = 10, i3 = 128, i4 = 128; System.out.println(i1 == i2); System.out.println(i1.equals(i2)); System.out.println(i3 == i4); System.out.println(i3.equals(i4)); &#125;&#125; 看这一段代码，我第一反应就是 1234truetruetruetrue 结果实际执行效果是 1234truetruefalsetrue 仔细研究了一下，发现JVM在自动拆装箱的时候会调用valueOf()方法，让我们来看一下Integer的valueOf()方法： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 注释里写明了Integer会缓存[-128, 127]之间的值，结合代码也可以看出如果Integer对象携带的整形如果是[128, 127]之间则直接返回这个Integer，否则新建一个Integer。 这个坑就显而易见了, Java中==比较的是地址，两个不同的对象地址显然不一样，所以会有上面令我匪夷所思的结果。 这坑让我意识到即使Java里有自动拆装箱， 也不能依赖这个特性，否则就是深渊呐，对象还是老老实实的用equals(T)比较吧 toString()方法 12345678public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return "-2147483648"; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); char[] buf = new char[size]; getChars(i, size, buf); return new String(buf, true);&#125; 相关的方法实现 [ ] stringSize(int x); 返回正整数x的位数 123456789final static int [] sizeTable = &#123; 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE &#125;;// Requires positive x, 返回正整数x的位数static int stringSize(int x) &#123; for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1;&#125; 123456789101112131415161718192021222324252627282930313233static void getChars(int i, int index, char[] buf) &#123; int q, r; int charPos = index; char sign = 0; if (i &lt; 0) &#123; sign = '-'; i = -i; &#125; // Generate two digits per iteration while (i &gt;= 65536) &#123; q = i / 100; // really: r = i - (q * 100); r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); i = q; buf [--charPos] = DigitOnes[r]; buf [--charPos] = DigitTens[r]; &#125; // Fall thru to fast mode for smaller numbers // assert(i &lt;= 65536, i); for (;;) &#123; q = (i * 52429) &gt;&gt;&gt; (16+3); r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ... buf [--charPos] = digits [r]; i = q; if (i == 0) break; &#125; if (sign != 0) &#123; buf [--charPos] = sign; &#125;&#125; int signum(int i); 判断i的值是否大于0，如果i是正数，返回1；i等于0，返回0；i为负数，返回-1. 1234public static int signum(int i) &#123; // HD, Section 2-7 return (i &gt;&gt; 31) | (-i &gt;&gt;&gt; 31);&#125; Integer高级方法总结 //highestOneBit。保留最高位的1，同时将低位全部清零 12System.out.println(Integer.highestOneBit(1023));System.out.println("lowest one bit: " + Integer.lowestOneBit(12)); //numberOfLeadingZeros。返回最高位的1之前0的个数。例如：1101000即104返回32-7=25 12System.out.println("number of leading zeros: " + Integer.numberOfLeadingZeros(104));//25System.out.println("number of leading zeros: " + Integer.numberOfLeadingZeros(2));//30 //numberOfTrailingZeros。返回最低位的1之后0的个数。例如：1101000即104返回3 System.out.println(&quot;number of trailing zeros: &quot; + Integer.numberOfTrailingZeros(104));//3 //reverse。反转二进制补码中位的顺序。即将第32位的值与第1位的值互换，第31位的值与第2位的值互换，等等，依次 12System.out.println("reverse: " + Integer.toBinaryString(Integer.reverse(7)));//得11100000000，即最低位的三个一跑到最高位去了System.out.println("reverse: " + Integer.toBinaryString(Integer.reverse(13)));//得到101100000 //reverseBytes:将第一个字节与第四个字节的位置互换，第二个字节与第三个字节位置互换 System.out.println(&quot;reverse bytes: &quot; + Integer.toHexString(Integer.reverseBytes(0x4835)));//打印35480000 //rotateLeft。将i左移distance,如果distance为负，则右移-distance 123System.out.println(&quot;rotate left: &quot; + Integer.rotateLeft(7, 2));//打印28System.out.println(&quot;rotate left: &quot; + Integer.rotateLeft(28, -2));//实际为向右移2，打印7 //rotateRight。将i无符号右移distance,如果distance为负，则左移-distance。负的肯定会移成正的。 System.out.println(&quot;rotate left: &quot; + Integer.rotateRight(-7, 2));//打印28]]></content>
      <categories>
        <category>技术</category>
        <category>Java</category>
        <category>Java Core</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Integer</tag>
        <tag>java源码分析</tag>
      </tags>
  </entry>
</search>
