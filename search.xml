<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[LaTeX学习]]></title>
    <url>%2Ftechnology%2FLaTeX%E5%AD%A6%E4%B9%A0.html</url>
    <content type="text"><![CDATA[LaTeX学习 如果你平时的写作中会遇到数学公式，而你又是使用的markdown编辑器，那么，本文适合你。 本文主要介绍LaTex数学排版在MarkDown语法中的使用。如果您需要的是更详尽的LaTeX论文排版等，请查阅相关专业资料。 TEX 是Donald E. Knuth 编写的一个以排版文章及数学公式为目标的计算机程序。TEX的版本号不断趋近于π，现在为3.141592。由Pascal 语言写成，特点: 免费、输出质量高、擅长科技排版、有点像编程。 LATEX 目前使用最广泛的TEX 宏集。 每一个LATEX 命令实际上最后都会被转换解释成几个甚至上百个TEX命令。 CTEX 国内致力于TEX 推广的网站：www.ctex.org/。该网站提供了CTEX 中文套装，这个安装程序把MiKTEX（TEX 在Windows 操作系统上的实现版本）和一些相关工具（如WinEdt、GSview 等）打包在一起，同时对中文接口进行了配置，以实现对中文文本的编辑。 如果想学习LATEX安装CTEX套装就可以了。LATEX 的功能和宏包有很多，每个人用到的功能是有限的；边用边学，建立了基本的概念以后，在使用中根据需求去解决问题就可以了。 LaTeX公式基础知识 LATEX控制序列的概念（类似于函数） 控制序列可以是作为命令：以\开头，参数：必须参数{}和可选参数[]。 环境概念 以bengin {环境名}开始，并以end {环境名}结束。 LaTeX 公式有两种，一种是用在正文中的，一种是单独显示的。正文中的公式用 $...$ 来定义，单独显示的用$$...$$ 来定义，其中 ... 表示的是LaTeX 的公式命令。 行内公式： $f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t$.(行内公式) \(f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t\) ​ 行间公式： $$f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t{6}\tag{1}$$ \[f(x) = \sum_{i=0}^{N}\int_{a}^{b} g(t,i) \text{ d}t{6}\tag{1}\] 上标与下标 上标命令是 ^{角标}，下标命令是_{角标}。当角标是单个字符时可以不用花括号 分式 输入较短的分式时，最简单的方法是使用斜线，譬如输入(x+y)/2，可得到：\((x + y)/2\) 要输入带有水平分数线的公式，可用命令：\frac{分子}{分母}。 eg. $$\frac{x+y}{2}$$ \[\frac{x+y}{2}\] $$\frac{1}{1+\frac{1}{2}}$$ \[\frac{1}{1+\frac{1}{2}}\] 根式 排版根式的命令是：开平方：\sqrt{表达式}；开 n 次方：\sqrt[n]{表达式} $$\sqrt{2}&lt;\sqrt[3]{3}$$ \[\sqrt{2}&lt;\sqrt[3]{3}\] $$\sqrt{1+\sqrt[p]{1+a^2}}$$ \[\sqrt{1+\sqrt[p]{1+a^2}}\] $$\sqrt{1+\sqrt[^p\!]{1+a^2}}$$ \[\sqrt{1+\sqrt[^p\!]{1+a^2}}\] 求和与积分 排版求和符号与积分符号的命令分别为 \sum和 \int，它们通常都有上下限，在排版上就是上标和下标。 $$\sum_{k=1}^{n}\frac{1}{k}$$ \[\sum_{k=1}^{n}\frac{1}{k}\] 微分符直体：$$\int_a^b f(x)\mathrm{d}x$$ \[\int_a^b f(x)\mathrm{d}x\] 公式中的空格 LaTeX 能够自动处理公式中的大多数字符之间的空格，但是有时候需要自己手动进行控制。 命令 释义 显示 $a\!b$ 紧贴 \(a\!b\) $ab$ 没有空格 \(ab\) $a\,b$ 小空格 \(a\,b\) $a\;b$ 中等空格 \(a\;b\) $ab$ 大空格 \(a\ b\) $a\quad b$ quad空格 \(a\quad b\) $a\qquad b$ 两个quad空格 \(a\qquad b\) 西文字符转换表 命令 释义 命令 释义 rm 罗马字体 \it 意大利字体 \bf 黑体 \sl 倾斜体 \sf 等线体 \sc 小体大写字母 \tt 打字机字体 \mit 数学斜体 \cal 数学中花体字母 公式中的定界符 这里所谓的定界符是指包围或分割公式的一些符号 $($ %( $)$ %) $[$ %[ $]$ %] $\{$ %{ $\}$ %} $|$ %| $\|$ %|| 在上述这些定界符之前冠以 \left（修饰左定界符）或 \right（修饰右定界符），可以得到自适应缩放的定界符，它们会根据定界符所包围的公式大小自适应缩放。 $$\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)$$ \[\left(\sum_{k=\frac{1}{2}}^{N^2}\frac{1}{k}\right)\] 矩阵 对于少于 10 列的矩阵，可使用matrix，pmatrix，bmatrix，Bmatrix，vmatrix 和Vmatrix 等环境。 $$\begin{matrix}1 &amp; 2\\3 &amp;4\end{matrix}$$ \[\begin{matrix}1 &amp; 2\\3 &amp;4\end{matrix}\] $$\begin{pmatrix}1 &amp; 2\\3 &amp;4\end{pmatrix}$$ \[\begin{pmatrix}1 &amp; 2\\3 &amp;4\end{pmatrix}\] $$\begin{bmatrix}1 &amp; 2\\3 &amp;4\end{bmatrix}$$ \[\begin{bmatrix}1 &amp; 2\\3 &amp;4\end{bmatrix}\] $$\begin{Bmatrix}1 &amp; 2\\3 &amp;4\end{Bmatrix}$$ \[\begin{Bmatrix}1 &amp; 2\\3 &amp;4\end{Bmatrix}\] $$\begin{vmatrix}1 &amp; 2\\3 &amp;4\end{vmatrix}$$ \[\begin{vmatrix}1 &amp; 2\\3 &amp;4\end{vmatrix}\] $$\begin{Vmatrix}1 &amp; 2\\3 &amp;4\end{Vmatrix}$$ \[\begin{Vmatrix}1 &amp; 2\\3 &amp;4\end{Vmatrix}\] 排版数组 当矩阵规模超过 10 列，或者上述矩阵类型不敷需求，可使用 array 环境。该环境可把一些元素排列成横竖都对齐的矩形阵列。 12345678$$\mathbf&#123;X&#125; =\left( \begin&#123;array&#125;&#123;ccc&#125;x_&#123;11&#125; &amp; x_&#123;12&#125; &amp; \ldots \\x_&#123;21&#125; &amp; x_&#123;22&#125; &amp; \ldots \\\vdots &amp; \vdots &amp; \ddots\end&#123;array&#125; \right)$$ \[ \mathbf{X} = \left( \begin{array}{ccc} x_{11} &amp; x_{12} &amp; \ldots \\ x_{21} &amp; x_{22} &amp; \ldots \\ \vdots &amp; \vdots &amp; \ddots \end{array} \right) \] \mathbf大写控制符，\\表示换行，{ccc}表示列样式。array 环境也可以用来排版这样的表达式，表达式中使用一个. 作为其隐藏的\right定界符。 1234567$$y = \left\&#123; \begin&#123;array&#125;&#123;ll&#125;a &amp; \textrm&#123;if $d&gt;c$&#125;\\b+x &amp; \textrm&#123;in the morning&#125;\\l &amp; \textrm&#123;all day long&#125;\end&#123;array&#125; \right.$$ \[ y = \left\{ \begin{array}{ll} a &amp; \textrm{if $d&gt;c$}\\ b+x &amp; \textrm{in the morning}\\ l &amp; \textrm{all day long} \end{array} \right. \] 也可以在array环境中画线，如分隔矩阵中元素。 1234567$$\left(\begin&#123;array&#125;&#123;c|c&#125;1 &amp; 2 \\\hline3 &amp; 4\end&#123;array&#125;\right)$$ \[ \left(\begin{array}{c|c} 1 &amp; 2 \\ \hline 3 &amp; 4 \end{array}\right) \] 基本LaTeX 公式命令 希腊字母 命令 显示 \alpha \(\alpha\) \beta \(\beta\) \gamma \(\gamma\) \delta \(\delta\) \zeta \(\zeta\) \epsilon \(\epsilon\) \eta \(\eta\) \theta \(\theta\) \iota \(\iota\) \kappa \(\kappa\) \lambda \(\lambda\) \mu \(\mu\) \xi \(\xi\) \nu \(\nu\) \pi \(\pi\) \rho \(\rho\) \sigma \(\sigma\) \tau \(\tau\) \upsilon \(\upsilon\) \phi \(\phi\) \chi \(\chi\) \psi \(\psi\) \omega \(\omega\) 如果使用大写的希腊字母，把命令的首字母变成大写即可，例如 \Gamma 输出的是 \(\Gamma\)。 如果使用斜体大写希腊字母，再在大写希腊字母的LaTeX命令前加上var，例如\varGamma 生成 \(\varGamma\)。 eg. 123$$ \varGamma(x) = \frac&#123;\int_&#123;\alpha&#125;^&#123;\beta&#125; g(t)(x-t)^2\text&#123; d&#125;t &#125;&#123;\phi(x)\sum_&#123;i=0&#125;^&#123;N-1&#125; \omega_i&#125; \tag&#123;2&#125;$$ 生成如下结果： \[ \varGamma(x) = \frac{\int_{\alpha}^{\beta} g(t)(x-t)^2\text{ d}t }{\phi(x)\sum_{i=0}^{N-1} \omega_i} \tag{2} \] 和号和积分号 命令 显示 \sum \(\sum\) \int \(\int\) \sum_{i=1}^{N} \(\sum_{i=1}^{N}\) \int_{a}^{b} \(\int_{a}^{b}\) \prod \(\prod\) \iint \(\iint\) \prod_{i=1}^{N} \(\prod_{i=1}^{N}\) \iint_{a}^{b} \(\iint_{a}^{b}\) \bigcup \(\bigcup\) \bigcap \(\bigcap\) \bigcup_{i=1}^{N} \(\bigcup_{i=1}^{N}\) \bigcap_{i=1}^{N} \(\bigcap_{i=1}^{N}\) 其它常用命令 命令 显示 \sqrt[3]{2} \(\sqrt[3]{2}\) \sqrt{2} \(\sqrt{2}\) x^{3} \(x^{3}\) x_{3} \(x_{3}\) \lim_{x \to 0} \(\lim_{x \to 0}\) \frac{1}{2} \(\frac{1}{2}\) 注意：上标和下标在只有一个字符时，可以不用中括号: x^2和x^{2}的结果都是 \(x^2\) 数学符号的修饰 命令 释义 显示 \overline{数学公式} 上划线 \(\overline{数学公式}\) \underline{数学公式} 下划线 \(\underline{数学公式}\) \overbrace{数学表达式} 俯卧式花括号 \(\overbrace{数学表达式}\) \underbrace{数学表达式} 仰卧式花括号 \(\underbrace{数学表达式}\) LaTeX学术写作 目前markdown语法对于LaTeX的支持比较有限，主要是公式语法，对于论文写作的语法支持很少。 \(\title[LaTeX公式语法]{markdown中对于LaTeX语法的支持}\) \(\subtitle{subtitle here}\) \(\author[Laphi\;Lee]{Laphi Lee}\)]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>LaTeX</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git拾遗]]></title>
    <url>%2Ftechnology%2Fgit%E6%8B%BE%E9%81%97.html</url>
    <content type="text"><![CDATA[整理一些git中非常有用且自己又容易忘记的命令，仅供参考。 github上fork代码后，从自己的代码库拉下代码。如何保持自己库中的代码和原代码的更新保持一致呢？ 步骤： 在 Fork 的代码库中添加上游代码库的 remote 源，该操作只需操作一次即可。 如: 其中 upstream 表示上游代码库名， 可以任意。 git remote add {upstream} git@github.com:spring-projects/spring-framework.git 将本地的修改提交 commit 在每次 Pull Request 前做如下操作，即可实现和上游版本库的同步。 ​ 3.1 ： git remote update upstream ​ 3.2 ： git rebase upstream/{branch name} 需要注意的是在操作3.2之前，一定要将checkout到{branch name}所指定的branch， 如: git checkout develop push 代码到 github ​ git push origin {branch name} git在本地新建分支并与远程库建立关联的几种方法 git checkout --track origin/remote_branch（推荐） 基于远程分支“remote_branch”，创建一个叫“remote_branch”的本地分支。 git checkout -b remote_branch origin/remote_branch git clone -b {remote_branch} git@github.com:spring-projects/spring-framework.git git branch remote_branch , git checkout remote_branch, git pull origin remote_branch git branch --set-upstream-to=origin/&lt;branch&gt; {remote_branch} git设置提交代码时显示的提交人信息 git config —global user.name laphi git config —global user.email laphi@laphilee.com 生成git帐号关联邮箱的rsa：git ssh-keygen -t rsa -C laphi@laphilee.com。 这里不强制要求用git生成rsa，直接用不和邮箱信息关联的rsa也完全可以。 git删除远程分支 如果一不小心把本地的临时分支push到server上去了，想要删除。怎么办？ 用git branch -r -d origin/branch-name只是删除的本地对该远程分支的track，不能删除远程服务器（如github，gitlab等）上的该分支。正确的方法应该是这样：git push origin :branch-name冒号前面的空格不能少，原理是把一个空分支push到server上，相当于删除该分支。 或者用命令git push origin --delete &lt;branchName&gt; 删除不存在对应远程分支的本地分支 假设这样一种情况： 我创建了本地分支b1并pull到远程分支 origin/b1； 其他人在本地使用fetch或pull创建了本地的b1分支； 我删除了 origin/b1 远程分支； 其他人再次执行fetch或者pull并不会删除这个他们本地的 b1 分支，运行 git branch -a 也不能看出这个branch被删除了，如何处理？ 使用下面的代码查看b1的状态： 123456789101112$ git remote show origin* remote origin Fetch URL: git@github.com:xxx/xxx.git Push URL: git@github.com:xxx/xxx.git HEAD branch: master Remote branches: master tracked refs/remotes/origin/b1 stale (use &apos;git remote prune&apos; to remove) Local branch configured for &apos;git pull&apos;: master merges with remote master Local ref configured for &apos;git push&apos;: master pushes to master (up to date) 这时候能够看到b1是stale的，使用 git remote prune origin 可以将其从本地版本库中去除。 更简单的方法是使用这个命令，它在fetch之后删除掉没有与远程分支对应的本地分支： git fetch -p 重命名远程分支 在Git中重命名远程分支，其实就是先删除远程分支，然后重命名本地分支，再重新提交一个远程分支。 123xiaosi@Q:~/code/qt$ git branch -av* dev 8d807de MOD master f600e50 code change during build remotes/origin/HEAD -&gt; origin/master remotes/origin/dev 8d807de MOD remotes/origin/master f600e50 code change during build 删除远程分支：git push --delete origin dev 重命名本地分支：git branch -m dev develop 推送本地分支：git push origin develop 设置git区分文件名大小写 git 默认是不区分文件名大小写的，当我们不小心把文件名的大小写写错了，想改过来，会发现push不起作用。 譬如当你创建一个文件后，叫 readme.md 写入内容后 提交到线上代码仓库。然后你在本地修改文件名为Readme.md 接着你去提交，发现代码没有变化.git status无任何提示信息。 这里有两种解决方法 配置git使其对文件名大小写敏感：git config core.ignorecase false 在本地仓库把文件删除，提交，然后push到远程仓库，然后再在本地重新添加正确文件名的文件，然后再push。 删除 1git rm readme.md push到远程仓库 12git commit -m 'readme.md'git push origin &lt;my_branch&gt; 重新添加 1git add Readme.md 提交 12git commit -m 'Readme.md'git push origin &lt;my_branch&gt; 这里推荐使用第一种方法，一劳永逸。 rebase 使用rebase和其他分支直接合并（不推荐，会有很多冲突） 假设你现在基于远程分支“origin”，创建一个叫“mywork”的分支。 1$ git checkout -b mywork origin img 现在我们在这个分支做一些修改，然后生成两个提交(commit). 12345$ vi file.txt$ git commit$ vi otherfile.txt$ git commit... 但是与此同时，有些人也在“origin”分支上做了一些修改并且做了提交了. 这就意味着“origin”和“mywork”这两个分支各自“前进”了，它们之间“分叉”了。 img 在这里，你可以用“pull”命令把“origin”分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的“合并的提交”(merge commit): img 但是，如果你想让“mywork”分支历史看起来像没有经过任何合并一样，你也许可以用 git rebase: 12$ git checkout mywork$ git rebase origin 这些命令会把你的“mywork”分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到“.git/rebase”目录中),然后把“mywork”分支更新到最新的“origin”分支，最后把保存的这些补丁应用到“mywork”分支上。 img 当’mywork’分支更新之后，它会指向这些新创建的提交(commit),而那些老的提交会被丢弃。 如果运行垃圾收集命令(pruning garbage collection), 这些被丢弃的提交就会删除. （请查看 git gc) img 现在我们可以看一下用合并(merge)和用rebase所产生的历史的区别： img 在rebase的过程中，也许会出现冲突(conflict). 在这种情况，Git会停止rebase并会让你去解决 冲突；在解决完冲突后，用git-add命令去更新这些内容的索引(index), 然后，你无需执行 git-commit,只要执行: 1$ git rebase --continue 这样git会继续应用(apply)余下的补丁。 在任何时候，你可以用--abort参数来终止rebase的行动，并且“mywork” 分支会回到rebase开始前的状态。 1$ git rebase --abort 使用rebase来合并当前分支commit，然后再和其他分支merge（推荐） git rebase -i HEAD~8 合并最近的8次commit。 git rebase -i i870cs “i870cs” 为不参与合并的最后一个commit 注：commit排序为倒序。即最新的commit在最上面。 从第二行开始，将pick改为s(s, squash = use commit, but meld into previous commit ) wq保存并退出。 如果有冲突，修改冲突后 12git add . git rebase --continue 如果想放弃rebase，执行git rebase --abort 将rebase同步到远程：git push origin &lt;your-branch&gt; 标签（tag） 当代码写到一个里程碑版本的时候，为了方便日后查看版本以及代码回滚，这时候需要打tag 创建标签：git tag -a v20170725 -m &quot;打标签&quot; 或者根据指定的commit打tag：git tag -a v20170725 -m &quot;打标签&quot; dd98asd 将标签同步到远程(和操作普通分支没有区别)：git push origin v20170725 查看所有标签列表：git tag 可以用git show &lt;tagname&gt;查看标签信息： 12345tag v20170725Tagger: laphi &lt;laphi@laphilee.com&gt;Date: Tue Jul 25 09:39:27 2017 +0800我的tag]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[钓鱼&天气]]></title>
    <url>%2Flife%2F%E9%92%93%E9%B1%BC-%E5%A4%A9%E6%B0%94.html</url>
    <content type="text"><![CDATA[转载一个老钓鱼人的总结 说到钓鱼，就一定要谈论技巧，据我了解有四点最重要。即“善观气候、选准钓位、钓组合理、饵料对路”，分述如下。 一、善观气候 俗语说：“打鱼不问风浪事，焉能打得大鱼回。”垂钓也不例外，寒暑阴阳，风雨水流都直接影响钓鱼效果。 在一年中，“清明”和“霜降”两个节气冷暖适中好钓鱼。但绝非仅有这两个节气能钓到鱼，不同的季节采取不同的方法并对准不同时段亦可开竿取得好钓绩。从总体上看： 春钓一天，夏钓早晚，秋钓黄昏，冬钓午间； 钓阴不钓阳，钓暗不钓明，鱼类对光线比较敏感，它们为避开天敌形成喜阴怕阳和爱清静的习性，为此必须注意阴阳、明暗的变化。 这里说的阴阳、明暗有双重含义：一是阴天比晴天好钓；二是除冬天外，夜间比白天好钓，但有些鱼如鲢鳙、草鱼、鱤鱼则靠白天钓获，夜间则与之相反。盛春初夏，繁花似锦，百业俱兴，亦是钓鱼的大好时光，但在这一时段气候尤为多变，出门垂钓更要善观气候变化。 六个气候变化要注意 “房潮有雾切莫赶路”整天远山和高大建筑物群笼罩在浓雾之中，能见度低，同时居家平房板石地面及水泥地或高楼底层地面潮湿，墙壁”冒汗”，布满水珠的反潮天气，气压低不宜出门垂钓。 “雾退见山赶快下竿”在连续数天山边及高大建筑物云雾连天，突然天高气爽，又是阴天或多云天气，此时出门垂钓必有重大收获，故有“远山看得清，钓鱼无暇吃点心”的传云。 “暴冷暴热不出门，天气突变不垂钓”譬如久雨突然放晴或久晴暴雨突袭，这时水温急剧变化，鱼类不适应，垂钓效果必然欠佳。 此外还要注意另外两种现象：一种是“暴风骤雨你莫钓，风雨过后总丰收”。这里着重指的是台风多发季节，刮台风时不但难开竿放钓，且鱼类潜入深水避风，要等风停，水面清静或细雨蒙蒙，十拿九稳喜获丰收；二是“雷雨离钓场，雨中不下竿”。垂钓多在空旷、临山及平原大水面等区域，这些地方往往是雷区，且近年来多数钓友采用碳素钓竿属导电体，雨中易遭雷击极度危险，同时鱼也怕雷，冒雨垂钓也是白忙，以暂离钓位为宜。 “雨中水面冒蒸气，下竿垂钓最有利”尤其初春，细雨蒙蒙，水面热气腾腾，下雨溶氧，水里温度高，增进鱼类食欲是难得的钓鱼好时期，不可错过。 “水中冒泡泡，大鱼小鱼都好钓”这是钓者熟知的道理，鱼冒泡泡，是鱼类寻觅的一种讯号，春末初夏尤为常见，即时好钓鱼。但在这段时间冒沼气亦较为常见，为此要分清鱼泡泡与沼气泡。鱼泡泡：泡粒较小，多在两个或数个以上，如鲫、鳊等;鲤鱼、鲇鱼爱拱泥，呈现成片泡泡有其独特之处；沼气泡一般单个、粒体大。同时冒沼气时，水面较常见有胶状水膜或从水底向水面悬浮块状似如青苔物质，下风口最明显，这种自然现象是由水变质冒沼气，水中必缺氧，鱼类懒于觅食，要善断，把沼气泡误为鱼泡泡垂钓必空忙。 “鱼儿水面跳，远近都好钓”鱼儿水面跳春夏较为常见，无论池塘、湖泊、库区鱼儿水面戏耍跳跃，觅食积极，近钓远钓两相宜，必获好钓绩。但亦要严格识别“鱼浮头”的现象，“鱼儿水面张口，垂钓必空手”，鱼儿水面张口是由水中缺氧所致，一般先是鲢鱼、草鱼、鳊鱼，特别鲫鱼、罗非鱼、鳙鱼成群在水面张口，水中缺氧尤为厉害，这时鱼类自命不保，怎想觅食，除非钩鱼，垂钓定无所获。另有一种情况，清晨碰到河虾在水面浮游及成群堆集岸边及杂草边，亦是鱼难钓的时段，要等河虾沉入水中方可开竿，但当天往往鱼咬钩不太积极。 刮什么风也会直接影响 除上述六点外，如下几种情况也不容忽视。首先是风向，刮什么风也会直接影响 “东南风钓鱼好轻松，风起西南收竿回转” “宁钓北风寒，不钓南风暖” “微风好钓鱼，无风鱼难钓” “风大钓上层，无风靠底钓” 这些都要引起垂钓者注意的问题。 温度更是直接的影响 其次温度更是直接影响钓鱼效果。水面温度低于摄氏13度，只有到深水区域及避风的地方垂钓。温度高于摄氏35度，除了钓鲢鳙鱼、鲮鱼、草鱼例外，多数鱼类则游弋深塘，大面积水域却难以找到它们的踪影。再次温差也极为关键。“温差六和五，钓鱼好辛苦”。 一年四季温差在摄氏五度和六度之间（即曰平均温度最高温度与最低温度之间的温度为温差），水中多为缺氧天气不宜垂钓。“温差七、八、九，钓鱼归来送朋友”，温差在七、八、九度出钓必获丰收，自己吃不完只好奉送朋友，分享丰收喜悦。别看与六度只有一度之差，钓鱼效果就是不一样，见怪则不怪。对于温差也并非愈小愈好，温差小一般在寒冬与雨季，适合钓白鲫鱼、白鲦、翘嘴鱼白、鳊鲤等;温差大于10度以上，多在炎热的夏秋较为常见。 夏秋季节，“低温25℃，高温33℃，出门垂钓不空竿”，是难得钓鱼好时光。但低温上升到摄氏26度，高温升到摄氏36度以上白天鱼难钓，只有黄昏及夜钓最见成效。 天气是我们出钓制胜的法宝，象10月下旬的绵绵中小雨让很多垂钓爱好者失去垂钓的信心，也许这样的天气正是鱼欢虾乐的垂钓好时光。而11月初阳光明媚的晴好天气又激起了我们外出垂钓的欲望，虽然天气晴好但出钓的效果也许差强人意。什么样的天气鱼儿才会开心呢？什么样的天气才会带给我们垂钓之乐呢？决定垂钓天气的好坏有五大因素：温度，温差，湿度，气压，风。 温度：水温越低水中溶氧越丰富，当水温高于30度以上时水体趋于溶氧不足，水温越高水体与空气的对流越差。所以我们夏天至初秋总是觉得钓鱼找不到感觉，有时人感觉天气很凉爽但出钓效果差强人意（是由于水温没降水中缺氧）。当进入深秋后气温趋于向冷，日温差也慢慢变小，天气逐渐稳定，只要我们有时间出钓定会让我们有所收获。冬季垂钓鲫鱼往往比夏天强很多，而且个大体肥。冬季垂钓没有太阳的炽热，没有雷电暴雨大风的干扰，水温稳定溶氧丰富对垂钓利。 温差对钓鱼的影响 温差：这里主要指日温差（一日中最高温度与最低温度之差），若日温差超过10度以上鱼儿就会消耗很大一部分能量变温来达到适应环境，顺应自然，这时鱼儿觅食欲望低下还无食欲。当日温差在7度左右时鱼儿能正常觅食，对垂钓有利。 湿度和钓鱼的关系 湿度：当空气中湿度达到100%时，空气中弥漫着大量水蒸气，水与空气的对流交换受阻，水中溶氧不足，使水体缺氧，鱼儿要消耗体力来与之抗衡，这时鱼儿觅食欲望低下还无食欲。若空气湿度在70%以上时对垂钓影响较大，只有当空气湿度小于50%才会对垂钓有利。 气压对钓鱼的影响 气压：通常指1个标准大气压值为正常气压，若低于标准大气压值为低气压天气，当低气压天气出现时由于水体内部压力相对变大空气中的氧气不能正常的溶入水体进行对流（当低气压天气严重时水底污泥中的有毒气体溢出与水体混合使水质发生改变鱼儿浮头还死亡），水中缺氧，鱼儿迫切需要的是氧而不是食物，对垂钓非常不利。只有在标准大气压值正常还趋高的天气情况下水中溶氧正常还充足，鱼儿寻觅食物的欲望强烈，对垂钓有利。 风力对钓鱼影响 风：当风达到5级以上时对垂钓不利，细雨微风对垂钓有利（冬季里的雪雨寒风另当别论），由于雨水会给水体带来空气中丰富的氧气，而微风又起着捣拌机的功效使水体溶氧充足，鱼儿觅食积极。还有就是风向，风无论向什么方向吹只要一日内风向不变，水体水域中的溶氧稳定鱼就好钓，若一天中风向不停的改变着，水与空气的对流也变化着（风能吹到的地方溶氧就充足反知次之），在垂钓中反应出来就是鱼情时好时坏，若一天中风向不停的改变着，遇到这种天气对垂钓也很不利。 当我们了解了鱼与天气的的关系后，接下来我们只要了解各类型鱼在什么水域栖息，喜欢吃什么饵，做到心中有数垂钓起来就容易了。 天气变化对江，河，溪流影响较大。湖泊，大型水库次之。水面越小受天气影响越大。在垂钓中当我们遇到不利天气时我们可以选择流动的水域和大型的湖泊，水库，这样就可以机动灵活做到知已知比，方能出奇制胜。 这是我在平时垂钓中的感受和体会，还有很多地方不全面，望各位钓友一起商榷和探讨。 二、选准钓位 野钓鲫鱼的选位 其实钓鱼人都知道鲫鱼是除了白条之外最好钓的鱼。虽然其好钓的原因很多但主要有三点： 鲫鱼生长繁殖力强，适应水域广，遍布我国各地无污染的淡水水域，数量上较其它淡水鱼有很大优势。 其个体较小在提竿。溜鱼等技巧上要求不高。不需要很高的钓技。 鲫鱼属杂食性，且比较贪食，因此诱饵和钓饵的配制都不很复杂，只要掌握了关键的几点就不愁钓不到鱼。 之所以要谈鲫鱼的钓法并不是本人对鲫鱼有特殊的兴趣，只是因为本人虽然以有30多年的钓龄而网龄却不长。看到网上有很多初学钓鱼的人对鲫鱼感兴趣，因此想谈一谈自己多年来钓野鲫鱼的体会以供参考。 钓鲫鱼的选位和钓其它鱼是不同的。钓鲫鱼选位要选草边，岸边，选旮旮旯旯的地方。比如说在湖泊、水库等大水面钓鲫鱼要找和大水面相连的沟沟岔岔等局部小水面。如果没有沟岔就要选靠近岸边的凹处离岸不要太远，最好选在草边或者是与大水面相通的草洞，只要有适当的水深越是靠近草或岸越好，水深根据季节不同可选择0.5—3米之间（最多不超过5米）但选择岸边时，必须选择凹处，谚语云：“鲤鱼钓凸，鲫鱼钓凹”。冬天和初春可选在北岸或东岸，且离岸可稍远一点的深水。晚春就要选择潜水处。有些场合水深甚至只有0.3米只要水混也会有意想不到的钓获量（潜水钓可用4粒星漂，多了没用，以饵代坠或者用很小的铅坠。）秋季要选择南岸或西岸的背阴处只要有1—3米的水深就行，最好是找到水底深浅交界处的深水处或者斜坡的靠近坡底处效果会非常好。 就是钓草边季节不同，下钩点也不同，比如：春季应该钓草丛的南边，秋季就要钓草丛的北边，哪怕是只有一两棵草，根据季节不同选择草的向阳一侧或背阴一侧效果也会截然不同。在野钓过程中选择钓位和下钩点（钓点）非常重要，有时在同一个钓位，下钩点相差不足0.5米钓效却差距很大。特别是在水面不很大的水草溏里更是如此。 盛夏不是钓鱼的好季节，但不是不能钓，只是盛夏钓鱼无论是选位还是钓法上都要比春秋季节钓鱼更要复杂些，比如谚语中说的“早钓东，晚钓西”一般只在夏天才用的上。我说个夏季钓鱼的小门道大家不妨一试。定点打窝后，下钩时不要把钩下在窝子中间，比如你如果准备钓草边离草一尺远的地方，那么你大窝时要把窝打在离草1米远，下钩时把钩下在窝和草中间离草一尺远的地方会非常好。如果是钓岸边，要把钩下在窝的前方二尺左右的地方，其效果会比把钩下在窝子中好的多。 谚语中说的“春钓滩，夏钓潭，秋钓荫，冬钓阳。”虽然说的很好，但在实际应用中却有很多非常实际的细节问题需要注意。 我国地域辽阔960万平方公里虽然都是同一天立春，但各地的温度却差距很大。而且从立春到立夏有两个多月的时间。要说在这两个多月的时间内全国各地钓鱼都要钓滩显然是荒唐之说。所以“春钓滩”只是个广义的说法，要求更确切些就必须根据实际温度来决定。之所以要“春钓滩”的原因很多但起决定因素的只有两点： 到了春季温度回升浅滩比深水处水温升高的要早，浅滩处的水温高于深水处的水温。 水中的各种生物经过了漫长的冬天到了水温回升的季节那里水温高就到那里去，所以鱼到水温较高的浅滩不仅可以找到更适宜自身温度的生存环境，还可以在那里找到其它浮游生物来填饱饿了一冬的辘辘饥肠。 虽然鱼有三趋（趋温。趋氧。趋食），但在不同的季节却有主次之分：冬春季节主要趋温，要以温度为主要依据考虑选择钓位。盛夏主要趋氧，在炎热的夏天要以水中溶氧量的高低作为选择钓位的主要依据，比如选草边； 选下风口。而到了秋季鱼为了储存足够的越冬脂肪要大量进食，因此主要趋食，那里食物丰富就到那里去。比如回风湾（水面上积存漂浮物多的地方）。大树下。选择岸边的大树下要看当天的风向，如果是南风就要选择南岸的树下（以次类推），若是两到三天风向不变效果更佳。“夏钓潭”也不是绝对的。比如阴雨天气或者有风的天气选择有长出水面的草旁或回风湾效果会更好。 钓鱼的选位非常重要，但也是钓鱼技术中最难掌握的一个环节，要选好一个钓位——特别是选准一个好钓点（下钩点），要根据季节、天气、风向、地形、水情、鱼情、垂钓者的多少等方方面面的因素来考虑，不可死板硬套。要在长期的垂钓活动中多留心，多总结积累经验。切不可每到一处就急忙打窝，要在选择一处钓位之后先安好竿线试探水下地形，选准了下钩点之后再决定打窝点,做到有的放矢。 顺便再说几句根据天气选位 春季要尽量选择下风口的滩，只要不超过4级。因为下风口的水温相对较高。 夏季只要风力不超过4级也要尽量选择下风口，风力越大钓点要离岸越近，因为下风口水的溶氧量高。 秋季既要选择背阴处又要考虑选择下风口或者回风湾，因为那里的食物较多。 冬季则要选择背风处，因为下风口的水温会更低。 出钓前一天听天气预报时不仅要听阴晴风雨，还要注意昼夜最大温差和气压，如果出钓当天的温差大于13度或者气压低于1004佰帕，鱼就会非常难钓，钓草边或草洞会略好些，如果用的是台钓采取漂接钓法钓半水或钓浮会好一点。下风口或者回风湾会更好。回风湾效果会更好。 三、钓组合理 以重量计费的鱼池一般我是不去的，不是野钓就是钓只管不喂的低价鱼塘。这样，所遇环境往往对象鱼密度小，常常有小杂鱼。为了适应，我专门设计了一种钓组和相应的钓法。我已沿用了八年，感觉很好。 钓组 取绿色软渔线一段，用绿色是因为鱼对这种颜色不敏感，一端系一只钓钩，两钩间脑线长约30厘米。用手指从中间挑起，两钩脑线一长一短，相距5厘米左右，在手指下端部位打一个结，留出手指粗的套，用来连接主线。剪一条一厘米宽的铅皮，铅皮的重量相当于4-5目漂梢的排水量，也就是放上铅皮漂头在水面剩一目，拿下就上来4-5目。 每个钩的脑线上卷一块，长脑线上的铅皮移至短脑线钓钩的钩弯处，将铅皮卷一厘米长的中间对准钩弯顶部，用钳子夹紧。另外一个脑线上的铅皮卷在距钩柄3厘米处夹紧。然后，在套结与铅皮间的脑线上刷上101胶，作用是防止在垂钓时两脑线相互缠绕。其它结构和别的钓友没有什么区别。 调漂和使用 漂我采用浮力大且目段较粗的，一般漂目直径在1.5毫米左右，夜钓时就用3毫米的。一个原因是我已花甲之年，细了看不清;主要原因是可以达到我想要的效果。调漂时，空钩不落底，漂只露一点点尖，垂钓时只露一目。甩线时，尽量往前抛，落水后漂一立起来就往后拖竿，超过正常放竿位置十多厘米。当漂不动后，把竿推到正常放竿位置。 这时水下前钩卧底，脑线上的小坠斜立，短脑线钩直立水底。这样前钩没有鱼咬钩漂无信号，后钩当鱼儿觅食时的虚假动作反映到漂上就是点动，小杂鱼逗钩也是如此。因此，鲫鱼咬钩时，只出现黑漂或者送漂两种信号，很容易看清，提高了上钩率。 饵料对路 有句俗语：“甩到水缸里，神仙也无戏。”意思是野钓选位是最重要的，我认为野钓中第二位的就是诱饵。我的诱饵的主要成份：三分之一小米，三分之一玉米面，三分之一麦麸。制做方法：每公斤加50克羊油和70克精盐炒熟，装好备用;使用时，在前一天晚上加适量的糖、泡制的桂皮曲酒，最后用曲酒将所有饵料浸透，这样诱饵就制成了。 这种诱饵的特点是味浓，入水后饵雾存留时间长。有人会问为什么用盐，我过去的主要业余生活是冬猎夏钓，发现一些人为了让鹿按一定规律活动，使用撒盐的办法来引导。我想山里的鹿从未见过盐，怎么会被盐吸引？鱼会不会也对盐感兴趣？当试用后我发现鱼也喜欢盐。 钓友们说我最抠，我比谁用得诱饵都少。我的投饵器是老式的，用乒乓球和自行车内胎做的。第一次投饵多一些，以后每次只是刚刚盖住乒乓球。频率根据鱼情而定，一般不超过半小时就喂一次。投饵要集中，落饵点半径不超过10厘米，我一天最多用诱饵不超过300克。我的用意是，鱼寻味而来，到窝后最醒目，最吸引鱼的是钓饵。 我用钓饵也少，有时用蚯蚓，由于好闹小鱼，一般都是面食搓饵。大的像黄豆粒，小的像高粱米粒。搓饵的硬度和压面条的面一样，甚至还要硬，挂饵时手指要感觉到钓尖。目的： 减少挂饵的次数 抵挡小鱼逗钩 上鱼准确率高 原料：过去用细玉米面加糖，用开水烫过蒸熟，现在是商品饵。我的体会是：在野钓中，野生鱼一般对饵不太挑剔，两种饵的差别不大。不过，商品饵更理想，更方便。]]></content>
      <categories>
        <category>生活</category>
      </categories>
      <tags>
        <tag>Fishing</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Integer剖析]]></title>
    <url>%2Ftechnology%2FJava-Integer%E5%89%96%E6%9E%90.html</url>
    <content type="text"><![CDATA[Java Integer剖析 获取String的整型值的方法 public Integer valueOf(String str) Java获取字符串的十进制Integer整型值 123public static Integer valueOf(String s) throws NumberFormatException &#123; return Integer.valueOf(parseInt(s, 10));&#125; 底层调用的是Integer.parseInt(String s, int radix)，然后通过Integer.valueOf(int i)将parseInt返回的int值封装成Integer对象。 注意：Integer.valueOf(int i)中对需要封装成Integer的int值做了缓存，常用的Integer值，默认[－128～127］可直接通过缓存获取，否则新建Integer。这样也就导致了一个Integer的自动装箱的问题，后面谈到equals和==时我们再来分析。 123456public static Integer valueOf(int i) &#123; assert IntegerCache.high &gt;= 127; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)];//IntegerCache数组中存在，直接返回Integer 对象，否则创建新Integer对象 return new Integer(i);&#125; 当然这里的缓存int的最大值是可以设置的，通过java.lang.Integer.IntegerCache.high属性来设置。 1234567891011121314151617181920212223242526private static class IntegerCache &#123; static final int low = -128; static final int high; static final Integer cache[]; static &#123; // high value may be configured by property int h = 127; String integerCacheHighPropValue = sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high"); if (integerCacheHighPropValue != null) &#123; int i = parseInt(integerCacheHighPropValue); i = Math.max(i, 127);//默认最小的max值是127 // Maximum array size is Integer.MAX_VALUE h = Math.min(i, Integer.MAX_VALUE - (-low) -1);//确保cache数组的大小不超过Integer的最大限度 &#125; high = h; cache = new Integer[(high - low) + 1];//创建缓存数组，给定大小 int j = low; for(int k = 0; k &lt; cache.length; k++) cache[k] = new Integer(j++);//初始化缓存数组 &#125; private IntegerCache() &#123;&#125;&#125; public int parseInt(String str) 解析String的int值，返回int型数值 parseInt(String str) ，底层调用int parseInt(String s, int radix), radix默认10 123public static int parseInt(String s) throws NumberFormatException &#123; return parseInt(s,10);&#125; parseInt(String s, int radix)的实现如下。这个方法也是很著名的atoi（字符串转int），面试题里面出现的概率很高——想想如果让自己写代码来实现，能否写的出来？ 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869/***@param s 要转换成int的String字符串。parseInt只接收带‘＋’，‘－’或纯数值(8进制，16进制，10进制)，不自动判断进制数, 需要靠后面的radix来指定———区别于decode(String str)*@param radix String字符串中的数字的进制数*@return 转换后的十进制数*/public static int parseInt(String s, int radix) throws NumberFormatException&#123; /* * WARNING: This method may be invoked early during VM initialization * before IntegerCache is initialized. Care must be taken to not use * the valueOf method. */ if (s == null) &#123; throw new NumberFormatException("null"); &#125; if (radix &lt; Character.MIN_RADIX) &#123; throw new NumberFormatException("radix " + radix + " less than Character.MIN_RADIX"); &#125; if (radix &gt; Character.MAX_RADIX) &#123; throw new NumberFormatException("radix " + radix + " greater than Character.MAX_RADIX"); &#125; int result = 0; boolean negative = false; int i = 0, len = s.length(); int limit = -Integer.MAX_VALUE; int multmin; int digit; if (len &gt; 0) &#123; char firstChar = s.charAt(0); if (firstChar &lt; '0') &#123; // Possible leading "+" or "-" if (firstChar == '-') &#123; negative = true; limit = Integer.MIN_VALUE; &#125; else if (firstChar != '+') throw NumberFormatException.forInputString(s); if (len == 1) // Cannot have lone "+" or "-" throw NumberFormatException.forInputString(s); i++; &#125; multmin = limit / radix; while (i &lt; len) &#123; // Accumulating negatively avoids surprises near MAX_VALUE digit = Character.digit(s.charAt(i++),radix);//获取char的int值 if (digit &lt; 0) &#123; throw NumberFormatException.forInputString(s); &#125; if (result &lt; multmin) &#123; throw NumberFormatException.forInputString(s); &#125; result *= radix;//如传入String为“123”，radix为10.计算过程为i = ((-1*10 - 2)*10 - 3)*10 if (result &lt; limit + digit) &#123; throw NumberFormatException.forInputString(s); &#125; result -= digit; &#125; &#125; else &#123; throw NumberFormatException.forInputString(s); &#125; return negative ? result : -result;&#125; parseInt(String s,int radix)就是求int radix进制数String s的radix进制数是多少。 Integer decode(String nm) decode方法可以接收带有’0x’, ‘0X’, ‘#’(16进制)，‘0’(8进制)前缀的字符串，自动判断进制数，底层调用的Integer.valueOf(String str, int radix)——&gt;Integer.parseInt(String str, int radix)。 decode(String str)相对于parseInt(String str, int radix)多了自动判断进制数的功能，且返回值是Integer对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public static Integer decode(String nm) throws NumberFormatException &#123; int radix = 10; int index = 0; boolean negative = false; Integer result; if (nm.length() == 0) throw new NumberFormatException("Zero length string"); char firstChar = nm.charAt(0); // Handle sign, if present if (firstChar == '-') &#123; negative = true; index++; &#125; else if (firstChar == '+') index++; // Handle radix specifier, if present if (nm.startsWith("0x", index) || nm.startsWith("0X", index)) &#123; index += 2; radix = 16; &#125; else if (nm.startsWith("#", index)) &#123; index ++; radix = 16; &#125; else if (nm.startsWith("0", index) &amp;&amp; nm.length() &gt; 1 + index) &#123; index ++; radix = 8; &#125; if (nm.startsWith("-", index) || nm.startsWith("+", index)) throw new NumberFormatException("Sign character in wrong position"); try &#123; result = Integer.valueOf(nm.substring(index), radix);//底层调用valueOf(String str, int radix) --&gt; parseInt(String str, int radix) result = negative ? Integer.valueOf(-result.intValue()) : result; &#125; catch (NumberFormatException e) &#123; // If number is Integer.MIN_VALUE, we'll end up here. The next line // handles this case, and causes any genuine format error to be // rethrown. String constant = negative ? ("-" + nm.substring(index)) : nm.substring(index); result = Integer.valueOf(constant, radix); &#125; return result;&#125; Integer.getInteger(String str, Integer val); 此方法用于获取系统属性的Integer值 1234567/*** 如果需要获取系统的属性值的话，推荐使用getInteger(String nm, Integer val)，可以省去一层调用和一个判断*/public static Integer getInteger(String nm, int val) &#123; Integer result = getInteger(nm, null); return (result == null) ? Integer.valueOf(val) : result;&#125; 1234567891011121314151617181920/***@param nm 系统属性的名字，如"java.lang.Integer.IntegerCache.high"*@param val 获取系统属性失败的情况下的默认值*@return 属性对应的Integer值*/public static Integer getInteger(String nm, Integer val) &#123; String v = null; try &#123; v = System.getProperty(nm); &#125; catch (IllegalArgumentException e) &#123; &#125; catch (NullPointerException e) &#123; &#125; if (v != null) &#123; try &#123; return Integer.decode(v);//底层调用的decode，把str解析成对应的十进制Integer &#125; catch (NumberFormatException e) &#123; &#125; &#125; return val;&#125; 总结 Atoi使用推荐 返回值Integer 返回值int str是十进制 valueOf(String str) parseInt(String str) str非十进制 decode(String str)(需解析radix) ｜valueOf(String str, int radix)(不需要解析radix) parseInt(String str, int radix)(str不能带radix标识，但可以带‘＋’、‘－’号) Integer中的其它方法 compareTo(Integer anotherInteger) 比较两个Integer数值的大小 1234567/*** @param 要比较的另一个Integer* @return 相等返回0，小于anotherInteger返回－1，大于anotherInteger返回1*/public int compareTo(Integer anotherInteger) &#123; return compare(this.value, anotherInteger.value);&#125; 底层使用的方法 123public static int compare(int x, int y) &#123; return (x &lt; y) ? -1 : ((x == y) ? 0 : 1);&#125; Integer中的equals方法 123456public boolean equals(Object obj) &#123; if (obj instanceof Integer) &#123; return value == ((Integer)obj).intValue(); &#125; return false;&#125; 关于equals(Object obj)和==，自动装箱的坑 前两天看到一个面试题，大体就是下面这样的代码： 123456789public class Test &#123; public static void main(String[] args) throws Exception &#123; Integer i1 = 10, i2 = 10, i3 = 128, i4 = 128; System.out.println(i1 == i2); System.out.println(i1.equals(i2)); System.out.println(i3 == i4); System.out.println(i3.equals(i4)); &#125;&#125; 看这一段代码，我第一反应就是 1234truetruetruetrue 结果实际执行效果是 1234truetruefalsetrue 仔细研究了一下，发现JVM在自动拆装箱的时候会调用valueOf()方法，让我们来看一下Integer的valueOf()方法： 12345public static Integer valueOf(int i) &#123; if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high) return IntegerCache.cache[i + (-IntegerCache.low)]; return new Integer(i);&#125; 注释里写明了Integer会缓存[-128, 127]之间的值，结合代码也可以看出如果Integer对象携带的整形如果是[128, 127]之间则直接返回这个Integer，否则新建一个Integer。 这个坑就显而易见了, Java中==比较的是地址，两个不同的对象地址显然不一样，所以会有上面令我匪夷所思的结果。 这坑让我意识到即使Java里有自动拆装箱， 也不能依赖这个特性，否则就是深渊呐，对象还是老老实实的用equals(T)比较吧 toString()方法 12345678public static String toString(int i) &#123; if (i == Integer.MIN_VALUE) return "-2147483648"; int size = (i &lt; 0) ? stringSize(-i) + 1 : stringSize(i); char[] buf = new char[size]; getChars(i, size, buf); return new String(buf, true);&#125; 相关的方法实现 [ ] stringSize(int x); 返回正整数x的位数 123456789final static int [] sizeTable = &#123; 9, 99, 999, 9999, 99999, 999999, 9999999, 99999999, 999999999, Integer.MAX_VALUE &#125;;// Requires positive x, 返回正整数x的位数static int stringSize(int x) &#123; for (int i=0; ; i++) if (x &lt;= sizeTable[i]) return i+1;&#125; 123456789101112131415161718192021222324252627282930313233static void getChars(int i, int index, char[] buf) &#123; int q, r; int charPos = index; char sign = 0; if (i &lt; 0) &#123; sign = '-'; i = -i; &#125; // Generate two digits per iteration while (i &gt;= 65536) &#123; q = i / 100; // really: r = i - (q * 100); r = i - ((q &lt;&lt; 6) + (q &lt;&lt; 5) + (q &lt;&lt; 2)); i = q; buf [--charPos] = DigitOnes[r]; buf [--charPos] = DigitTens[r]; &#125; // Fall thru to fast mode for smaller numbers // assert(i &lt;= 65536, i); for (;;) &#123; q = (i * 52429) &gt;&gt;&gt; (16+3); r = i - ((q &lt;&lt; 3) + (q &lt;&lt; 1)); // r = i-(q*10) ... buf [--charPos] = digits [r]; i = q; if (i == 0) break; &#125; if (sign != 0) &#123; buf [--charPos] = sign; &#125;&#125; int signum(int i); 判断i的值是否大于0，如果i是正数，返回1；i等于0，返回0；i为负数，返回-1. 1234public static int signum(int i) &#123; // HD, Section 2-7 return (i &gt;&gt; 31) | (-i &gt;&gt;&gt; 31);&#125; Integer高级方法总结 //highestOneBit。保留最高位的1，同时将低位全部清零 12System.out.println(Integer.highestOneBit(1023));System.out.println("lowest one bit: " + Integer.lowestOneBit(12)); //numberOfLeadingZeros。返回最高位的1之前0的个数。例如：1101000即104返回32-7=25 12System.out.println("number of leading zeros: " + Integer.numberOfLeadingZeros(104));//25System.out.println("number of leading zeros: " + Integer.numberOfLeadingZeros(2));//30 //numberOfTrailingZeros。返回最低位的1之后0的个数。例如：1101000即104返回3 System.out.println(&quot;number of trailing zeros: &quot; + Integer.numberOfTrailingZeros(104));//3 //reverse。反转二进制补码中位的顺序。即将第32位的值与第1位的值互换，第31位的值与第2位的值互换，等等，依次 12System.out.println("reverse: " + Integer.toBinaryString(Integer.reverse(7)));//得11100000000，即最低位的三个一跑到最高位去了System.out.println("reverse: " + Integer.toBinaryString(Integer.reverse(13)));//得到101100000 //reverseBytes:将第一个字节与第四个字节的位置互换，第二个字节与第三个字节位置互换 System.out.println(&quot;reverse bytes: &quot; + Integer.toHexString(Integer.reverseBytes(0x4835)));//打印35480000 //rotateLeft。将i左移distance,如果distance为负，则右移-distance 123System.out.println(&quot;rotate left: &quot; + Integer.rotateLeft(7, 2));//打印28System.out.println(&quot;rotate left: &quot; + Integer.rotateLeft(28, -2));//实际为向右移2，打印7 //rotateRight。将i无符号右移distance,如果distance为负，则左移-distance。负的肯定会移成正的。 System.out.println(&quot;rotate left: &quot; + Integer.rotateRight(-7, 2));//打印28]]></content>
      <categories>
        <category>技术</category>
      </categories>
      <tags>
        <tag>Java</tag>
      </tags>
  </entry>
</search>
